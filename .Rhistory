test_hepatitis_b                  =   medhbvelisa, # TEXT
test_hepatitis_c                  =   medhcvelisa, # TEXT
test_hepatitis_e_virus            =   medhevelisa, # TEXT
test_hepatitis_e_igm              =   hevrecent, # TEXT
#  test_hepatitis_e_igg              =   , # TEXT               # (In same variable as elisa result)
test_hepatitis_e_genotype         =   hevgenotype, # TEXT
#  malaria_blood_film                =   , # TEXT               # (Not in dataset)
dengue                            =   dengue, # TEXT
yellow_fever                      =   yf, # TEXT
#  lassa_fever                       =   , # TEXT               # (Not in dataset)
#  typhoid                           =   , # TEXT               # (Not in dataset)
chikungunya_onyongnyong           =   chik, # TEXT
#  ebola_marburg                     =   , # TEXT               # (Not in dataset)
other_arthropod_transmitted_virus =   arbovpcr, # TEXT
#  other_pathogen                    =   , # TEXT               # (Not in dataset)
#  lab_comments                      =   , # TEXT               # (Not in dataset)
pregnant                          =   medpreg, # TEXT
trimester                         =   medpregtri, # TEXT
#  foetus_alive_at_admission         =   , # TEXT               # (Not in dataset)
#  delivery_event                    =   , # TRUE_ONLY          # (Not in dataset)
pregnancy_outcome_at_exit         =   medppoutcome, # TEXT
exit_status                       =   outcomehp, # TEXT
#  date_of_exit                      =   , # DATE               # (Not in dataset)
#  time_to_death                     =   , # TEXT               # (Not in dataset)
treatment_facility_site           =   hpid, # TEXT
#  treatment_location                =   , # ORGANISATION_UNIT  # (Not in dataset)
patient_origin_free_text          =   block # TEXT
)
# create a new variable for patient_facility_type
linelist_cleaned$patient_facility_type <- "Inpatient"
# Use this if your dataset does not align with the data dictionary
linelist_cleaned <- linelist_cleaned %>%
mutate_at(vars(matches("date|Date")), linelist::guess_dates,
error_tolerance = 0.5)
# Individually convert other date columns
class(linelist_cleaned$dthospitalisation)
linelist_cleaned$dthospitalisation <- linelist::guess_dates(linelist_cleaned$dthospitalisation)
class(linelist_cleaned$dthospitalisation)
# Repeat for variable "dtdeath"
linelist_cleaned$dtdeath <- linelist::guess_dates(linelist_cleaned$dtdeath)
# create an epiweek variable
# floor_day shortens to only give you the week number (rather than including day as well)
# factor includes all weeks between the min and max as levels (useful for zero count weeks)
linelist_cleaned$epiweek <- aweek::date2week(linelist_cleaned$date_of_onset,
floor_day = TRUE,
factor = TRUE)
## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years,
breakers = c(0, 3, 15, 30, 45))
## use this version for coded values (e.g. "DOA", "DD")
linelist_cleaned$DIED <- linelist_cleaned$exit_status %in% c("Décédé")
# Create a factor variable based on rules from other simple character variables
# If you have access to lab results, you can create a case definition variable
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
# starting from the specific to the general
# TRUE assigns all remaining rows
# You MUST modify this section to match your case definition. The below
# uses positive RDT for Confirmed and epi link only for Probable.
#
linelist_cleaned <- linelist_cleaned %>%
mutate(case_def = case_when(
is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
hep_e_rdt == "Positive"                               ~ "Confirmed",
hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
TRUE                                                  ~ "Suspected"
))
# vectors of variable names ----------------------------------------------------
## You may want to group the names of several variables that have the same possible
## values in to a named vector.
## This way if you want to run the same function over these variables you can
## simply use the named vector rather than typing out each variable individually
# create a grouping of all symptoms
SYMPTOMS <- c("generalized_itch",
#"history_of_fever",
"fever",
"joint_pains",
"epigastric_pain_heartburn",
"nausea_anorexia",
"vomiting",
"diarrhoea",
"bleeding",
"headache",
"mental_state",
#"convulsions",
"other_symptoms"
)
# create a grouping of all lab tests
LABS <- c("hep_b_rdt",
"hep_c_rdt",
"hep_e_rdt",
"test_hepatitis_a",
"test_hepatitis_b",
"test_hepatitis_c",
#          "test_hepatitis_e_igg",
"test_hepatitis_e_igm" ,
"test_hepatitis_e_genotype",
"test_hepatitis_e_virus",
"malaria_rdt_at_admission",
#          "malaria_blood_film",
"dengue",
#          "dengue_rdt",
"yellow_fever",
#          "typhoid",
"chikungunya_onyongnyong",
#          "ebola_marburg",
#          "lassa_fever",
"other_arthropod_transmitted_virus"
#          "other_pathogen"
)
# only keep variables with a case ID and a date of consultation
linelist_cleaned <- linelist_cleaned %>%
filter(!is.na(case_number) & !is.na(date_of_admission))
# drop cases after current week
# you will probably have cases in your dataset if case finding continues
# as these are after the week of reporting, drop them
linelist_cleaned <- linelist_cleaned %>%
filter(date_of_onset <= week2date(sprintf("%s-7", reporting_week)))
# define the first week of outbreak (date of first case)
first_week <- levels(linelist_cleaned$epiweek)[1]
# outbreak start
# return the first day in the week of first case
obs_start <- week2date(sprintf("%s-1", first_week))
# return last day of reporting week
obs_end   <- week2date(sprintf("%s-7", reporting_week))
# use if you have lab results in your data
# get counts and props of age groups by case definition
# include column and row totals
descriptive(linelist_cleaned, "age_group", "case_def", coltotals = TRUE, rowtotals = TRUE) %>%
rename("Age group" = age_group) %>%
rename_redundant(prop = "%") %>%
augment_redundant("_n$" = " cases (n)") %>%
kable(digits = 2)
descriptive(linelist_cleaned, "age_group", "sex", coltotals = TRUE, rowtotals = TRUE) %>%
rename("Age group" = age_group) %>%
rename_redundant(prop = "%") %>%
augment_redundant("_n$" = " cases (n)") %>%
kable(digits = 2)
descriptive(linelist_cleaned, "age_group", "sex",
coltotals = TRUE, rowtotals = TRUE, proptotal = TRUE) %>%
rename("Age group" = age_group) %>%
rename_redundant(prop = "%") %>%
augment_redundant("_n$" = " cases (n)") %>%
kable(digits = 2)
# plot age pyramid
plot_age_pyramid(linelist_cleaned,
age_group = "age_group",
split_by = "sex") +
labs(y = "Cases (n)", x = "Age group") + # change axis  labels (nb. x/y flip)
theme(legend.position = "bottom",     # move legend to bottom
legend.title = element_blank(), # remove title
text = element_text(size = 18)  # change text size
)
# get counts and proportions for all variables named in SYMPTOMS
multi_descriptive(linelist_cleaned, SYMPTOMS) %>%
# re-order columns (drop total_prop too)
select(symptom, Yes_n, Yes_prop, No_n, No_prop, Total_n) %>%
# rename accordingly
rename_redundant("prop" = "%") %>%
augment_redundant("_n$" = " (n)") %>%
kable(digits = 2)
# get counts and proportions for all variables named in LABS
multi_descriptive(linelist_cleaned, LABS, .id = "Lab test") %>%
# re-order columns (drop total_prop too)
select("Lab test", Pos_n, Positive_prop, Neg_n, Negative_prop,
"Not done_n", "Not done_prop", Total_n) %>%
# rename accordingly
rename("Unknown (n)" = "Not done_n") %>%
rename_redundant("prop" = "%") %>%
augment_redundant("_n$" = " (n)") %>%
kable(digits = 2)
# use arguments from above to produce overal CFR
overall_cfr <- linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
case_fatality_rate_df(deaths = DIED, mergeCI = TRUE) %>%
rename("Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci)
knitr::kable(overall_cfr, digits = 2)         # print nicely with 2 digits
linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
mutate(sex = forcats::fct_explicit_na(sex, "-")) %>%
case_fatality_rate_df(deaths = DIED, group = sex, mergeCI = TRUE, add_total = TRUE) %>%
rename("Sex" = sex,
"Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci) %>%
knitr::kable(digits = 2)
linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
case_fatality_rate_df(deaths = DIED, group = age_group, mergeCI = TRUE, add_total = TRUE) %>%
tidyr::complete(age_group,
fill = list(deaths = 0, population = 0, cfr = 0, ci = 0)) %>% # Ensure all levels are represented
rename("Age Group" = age_group,
"Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci) %>%
knitr::kable(digits = 2)
# Use if you have enough confirmed cases for comparative analysis
#
linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
case_fatality_rate_df(deaths = DIED, group = case_def, mergeCI = TRUE, add_total = TRUE) %>%
rename("Case Definition" = case_def,
"Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci) %>%
knitr::kable(digits = 2)
# OLD define population
population <- sum(population_data_age$population)
# Correct command for this exercise
population <- sum(population_data$population)
population_data <- rio::import("AJS_AmTiman_population_revised_for_template.xlsx", which="quartier")
# OLD define population
population <- sum(population_data_age$population)
# Correct command for this exercise
population <- sum(population_data$population)
# OLD define population
population <- sum(population_data_age$population)
# Correct command for this exercise
population <- sum(population_data$population)
# OLD define population
# population <- sum(population_data_age$population)
# Correct command for this exercise
population <- sum(population_data$population)
# Correct command for this exercise
population <- sum(population_data$population)
# Correct command for this exercise
population <- sum(population_data$population)
population
# calculate the ar
# store as AR to be able to use output for automating text below (inline functions)
ar <- attack_rate(nrow(linelist_cleaned), population, multiplier = 10000)
ar %>%
merge_ci_df(e = 3) %>% # merge the lower and upper CI into one column
rename("Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"95%CI" = ci) %>%
select(-Population) %>% # drop the population column as it is not changing
knitr::kable(digits = 2, align = "r")
View(population_data)
# This code creates case counts for each week of your outbreak, overall
# As with aweek, you can change the start of your week to e.g. "Sunday week"
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = "Monday week")
# this sets the theme in ggplot for epicurves
epicurve_theme <- theme(
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
legend.title = element_blank(),
panel.grid.major.x = element_line(color = "grey60", linetype = 3),
panel.grid.major.y = element_line(color = "grey60", linetype = 3)
)
# This sets the labels in ggplot for the epicurves
epicurve_labels <- labs(x = "Calendar week",
y = "Cases (n)",
title = "Cases by week of onset",
subtitle = sprintf("Source: MSF data from %s", reporting_week)
)
reporting_week <- "2017-W52"  # Set the reporting week
# This code creates case counts for each week of your outbreak, overall
# As with aweek, you can change the start of your week to e.g. "Sunday week"
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = "Monday week")
# this sets the theme in ggplot for epicurves
epicurve_theme <- theme(
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
legend.title = element_blank(),
panel.grid.major.x = element_line(color = "grey60", linetype = 3),
panel.grid.major.y = element_line(color = "grey60", linetype = 3)
)
# This sets the labels in ggplot for the epicurves
epicurve_labels <- labs(x = "Calendar week",
y = "Cases (n)",
title = "Cases by week of onset",
subtitle = sprintf("Source: MSF data from %s", reporting_week)
)
# plot your epicurve as a ggplot (incidence::plot is different to base::plot)
basic_curve <- plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates and remove legend title
epicurve_theme
# show your plot (stored for later use)
basic_curve
basic_curve + scale_x_incidence(inc_week_7, n_breaks = 6)
# counts and cumulative counts by week
cases <- linelist_cleaned %>%
arrange(date_of_onset) %>%        # arrange by date of onset
count(epiweek, .drop = FALSE) %>% # count all epiweeks and include zero counts
mutate(cumulative = cumsum(n))    # add a cumulative sum
# attack rate for each week
ar <- attack_rate(cases$n, population, multiplier = 100000) %>%
bind_cols(select(cases, epiweek), .) # add the epiweek column to table
ar %>%
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Epiweek" = epiweek,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"95%CI" = ci) %>%
knitr::kable(digits = 2, align = "r")
ar_plot <- ggplot(ar, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "blue", fill = "blue", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = ar), color = "blue", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "AR [95% CI]", subtitle = "Attack Rate (per 100,000)") +
# change visuals of dates and remove legend title
epicurve_theme
cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "CFR [95% CI]",
subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") +
# change visuals of dates and remove legend title
epicurve_theme
cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "CFR [95% CI]",
subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") +
# change visuals of dates and remove legend title
epicurve_theme
# group by known outcome and case definition
cfr <- linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
case_fatality_rate_df(grepl("Dead", exit_status), group = epiweek)
cfr %>%
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Epiweek" = epiweek,
"Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci) %>%
knitr::kable(digits = 2, align = "r")
cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "CFR [95% CI]",
subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") +
# change visuals of dates and remove legend title
epicurve_theme
nofx <- theme(axis.text.x = element_blank(),
axis.title.x = element_blank())
cowplot::plot_grid(
basic_curve + nofx,
ar_plot + nofx,
cfr_plot,
align = "v", # align plots vertically
axis = "lr", # only by their left and right margins
ncol = 1     # allow only one column
)
# get counts and props of region by facility
# include column and row totals
descriptive(linelist_cleaned, "patient_origin",
"patient_facility_type",
coltotals = TRUE, rowtotals = TRUE) %>%
rename("Region" = "patient_origin") %>%
augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
rename_redundant("prop" = "%")    %>% # rename proportions to %
kable(digits = 2)
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data_region, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
cases$n
cases$population
View(cases)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data_region, by = "patient_origin")    # merge population data
linelist_cleaned$patient_origin <- toupper(linelist_cleaned$patient_origin)
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data_region, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
View(cases)
cases <- count(linelist_cleaned, patient_origin)
View(population_data)
population$patient_origin %in% cases$patient_origin
class(population_data$patient_origin)
class(cases$patient_origin)
population_data$patient_origin %in% cases$patient_origin
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data, by = "patient_origin")    # merge population data
ar <- attack_rate(cases$n, cases$population, multiplier = 100000)
ar <- attack_rate(cases$n, cases$population, multiplier = 100)
attack_rate(cases=cases$n, population=cases$population, multiplier = 100)
attack_rate(10, 40, multiplier = 100)
attack_rate(cases$n, cases$population, multiplier = 100)
cases$n
cases$population
length(population_data$patient_origin %in% cases$patient_origin)
population_data$patient_origin %in% cases$patient_origin
length(NA)
res <- proportion(cases$n, cases$population, multiplier = 100000)
library(sitrep)
res <- proportion(cases$n, cases$population, multiplier = 100000)
proportion(cases$n, cases$population, multiplier = 100000)
proportion <- function(x, n, conf_level = 0.95, multiplier = 100) {
stopifnot(is.numeric(conf_level), conf_level >= 0, conf_level <= 1)
n <- if (length(n) < length(x)) rep(n, length(x)) else n
missing_data <- is.na(x) | is.na(x)
x[missing_data] <- 100
n[missing_data] <- 100
res <- binom::binom.wilson(x, n, conf.level = conf_level)
res <- res[, c("x", "n", "mean", "lower", "upper")]
res[missing_data, ] <- NA_real_
colnames(res) <- c("x", "n", "prop", "lower", "upper")
res$prop  <- (x / n) * multiplier
res$lower <- res$lower * multiplier
res$upper <- res$upper * multiplier
res
}
proportion(cases$n, cases$population, multiplier = 100000)
