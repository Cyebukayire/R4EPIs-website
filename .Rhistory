panel.grid.major.y = element_line(color = "grey60", linetype = 3)
)
# This sets the labels in ggplot for the epicurves
epicurve_labels <- labs(x = "Calendar week",
y = "Cases (n)",
title = "Cases by week of onset",
subtitle = sprintf("Source: MSF data from %s", reporting_week)
)
# plot your epicurve as a ggplot (incidence::plot is different to base::plot)
basic_curve <- plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates and remove legend title
epicurve_theme
# show your plot (stored for later use)
basic_curve
# This code creates case counts for two week groups of your outbreak, overall
# As with aweek, you can change the start of your week to e.g. "2 sunday weeks"
inc_week_14 <- incidence(linelist_cleaned$date_of_onset, interval = "2 Monday weeks")
# plot your epicurve
plot(inc_week_14, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_14)) +
scale_y_continuous(expand = c(0,0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates and remove legend title
epicurve_theme
# get counts by gender
inc_week_7_gender <- incidence(linelist_cleaned$date_of_onset,
interval = "Monday week",
groups = linelist_cleaned$sex)
# plot your epicurve
# here we remove the boxes around each case as it makes gender colours hard to see! (show_cases = FALSE)
plot(inc_week_7_gender, show_cases = FALSE, border = "black", n_breaks = nrow(inc_week_7_gender)) +
scale_y_continuous(expand = c(0,0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates, remove legend title and move legend to bottom
epicurve_theme
inc_week_7_water <- incidence(linelist_cleaned$date_of_onset,
interval = "Monday week",
groups = linelist_cleaned$water_source)
plot(inc_week_7_water, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7_water)) +
scale_y_continuous(expand = c(0,0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates, remove legend title and move legend to bottom
epicurve_theme
inc_week_7_sex_fac <- linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
with(incidence(date_of_onset, interval = "Monday week", groups = sex))
plot(inc_week_7_sex_fac, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7_sex_fac)) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# add labels to axes and below chart
epicurve_labels +
# change visuals of dates, remove legend title and move legend to bottom
epicurve_theme
# counts and cumulative counts by week
cases <- linelist_cleaned %>%
arrange(date_of_onset) %>%        # arrange by date of onset
count(epiweek, .drop = FALSE) %>% # count all epiweeks and include zero counts
mutate(cumulative = cumsum(n))    # add a cumulative sum
# attack rate for each week
ar <- attack_rate(cases$n, population, multiplier = 100000) %>%
bind_cols(select(cases, epiweek), .) # add the epiweek column to table
ar %>%
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Epiweek" = epiweek,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"95%CI" = ci) %>%
knitr::kable(digits = 2, align = "r")
# cumulative attack rate by week
attack_rate(cases$cumulative, population, multiplier = 100000) %>%
bind_cols(select(cases, epiweek), .) %>% # add the epiweek column to table
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Epiweek" = epiweek,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"95%CI" = ci) %>%
knitr::kable(digits = 2, align = "r")
# group by known outcome and case definition
cfr <- linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
case_fatality_rate_df(grepl("Dead", exit_status), group = epiweek)
cfr %>%
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Epiweek" = epiweek,
"Deaths" = deaths,
"Cases" = population,
"CFR (%)" = cfr,
"95%CI" = ci) %>%
knitr::kable(digits = 2, align = "r")
ar_plot <- ggplot(ar, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "blue", fill = "blue", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = ar), color = "blue", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "AR [95% CI]", subtitle = "Attack Rate (per 100,000)") +
# change visuals of dates and remove legend title
epicurve_theme
cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
geom_ribbon(aes(ymin = lower, ymax = upper),
color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
# scale the x axis the same as the incidence curve. Expand forces it to align.
incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
# add labels to axes and below chart
labs(x = "Calendar week", y = "CFR [95% CI]",
subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") +
# change visuals of dates and remove legend title
epicurve_theme
nofx <- theme(axis.text.x = element_blank(),
axis.title.x = element_blank())
cowplot::plot_grid(
basic_curve + nofx,
ar_plot + nofx,
cfr_plot,
align = "v", # align plots vertically
axis = "lr", # only by their left and right margins
ncol = 1     # allow only one column
)
# get counts and props of admissions by epiweek and case definition
# include column and row totals
descriptive(linelist_cleaned, "epiweek", "patient_facility_type", coltotals = TRUE, rowtotals = TRUE) %>%
augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
rename_redundant("prop" = "%")    %>% # rename proportions to %
kable(digits = 2)
# get counts and props of admissions by epiweek among inpatients
# include column and row totals
linelist_cleaned %>%
filter(patient_facility_type == "Inpatient") %>%
descriptive("epiweek", "exit_status2",
coltotals = TRUE, rowtotals = TRUE) %>%
rename("Week" = "epiweek") %>%
augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
rename_redundant("prop" = "%")    %>% # rename proportions to %
kable(digits = 2)
# get counts and props of region by facility
# include column and row totals
descriptive(linelist_cleaned, "patient_origin",
"patient_facility_type",
coltotals = TRUE, rowtotals = TRUE) %>%
rename("Region" = "patient_origin") %>%
augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
rename_redundant("prop" = "%")    %>% # rename proportions to %
kable(digits = 2)
# get counts and props of region by outcome among inpatients
# include column and row totals
descriptive(filter(linelist_cleaned,
patient_facility_type == "Inpatient"),
"patient_origin", "exit_status2",
coltotals = TRUE, rowtotals = TRUE) %>%
rename("Region" = "patient_origin") %>%
augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
rename_redundant("prop" = "%")    %>% # rename proportions to %
kable(digits = 2)
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
left_join(population_data_region, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
ar %>%
merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column
rename("95%CI" = ci) %>%  # rename single 95%CI column
kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
# plot with the region on the x axis sorted by increasing ar
# ar value on the y axis
ggplot(ar, aes(x = reorder(Region, `AR (per 100,000)`),
y = `AR (per 100,000)`)) +
geom_bar(stat = "identity", col = "black", fill = "red") + # plot as bars (identity = as is)
geom_errorbar(aes(ymin = `Lower 95%CI`, ymax = `Upper 95%CI`), width = 0.2) + # add CIs
scale_y_continuous(expand = c(0,0)) +  # set origin for axes
# add labels to axes and below chart
labs(x = "Region", y = "AR (per 100,000)",
captions = paste0("Source: MSF data from ", reporting_week)) +
epicurve_theme
deaths <- group_by(linelist_cleaned, patient_origin) %>%
filter(grepl("Dead", exit_status)) %>%
summarise(deaths = n()) %>% # count deaths by region
left_join(population_data_region, by = "patient_origin") # merge population data
mortality_rate(deaths$deaths, deaths$population, multiplier = 10000) %>%
# add the region column to table
bind_cols(select(deaths, patient_origin), .) %>%
merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
rename("Region" = patient_origin,
"Deaths" = deaths,
"Population" = population,
"Mortality (per 10,000)" = `mortality per 10 000`,
"95%CI" = ci) %>%
kable(digits = 2)
# DELETE THIS LINE IF YOU HAVE YOUR OWN SHAPEFILE
# generate fake shapefile
map <- gen_polygon(regions = unique(linelist_cleaned$patient_origin))
## Checklist for Shapefiles ----------------------------------------------
##
## - [ ] Your shapefile can be a polygon or points
##          - [ ] Polygons do not need to be contiguous
## - [ ] make sure the regions named in your shapefile match the appropriate variable in your linelist!
##          - [ ] this is usually the slot ID or NAME in most shapefiles
## - [ ] Check to make sure your coordinate reference system is WGS84 (this is the standard)
##        depending on how your shapefile was made it could in a different CRS
##        this could give you trouble down the line if you want to combine plots with eg. GPS points
## - [ ] DELETE OR COMMENT OUT THE FAKE SHAPEFILE SECTION
## reading in a shapefile
## shapefiles consist of multiple files
## so you dont need to specify the file type (reas_sf recognises it for you)
# map <- read_sf(here("mapfolder", "region"))
## check the coordinate reference system (CRS)
# st_crs(map)
## set the CRS if not present using EPSG value
## this is the most commonly used
# map <- st_set_crs(map, value = 4326) # Sets to WGS84
## Checklist for plotting ----------------------------------------------
## - [ ] consider making categorical groupings of your AR or counts variable
## - [ ] merge your attack rate or counts table with your shapefile
## - [ ] Choose the appropriate section below depending on if you are plotting polygons or points
## - [ ] Choose what variable you would like to fill (for polygons) or colour (for points) with (counts or AR)
## - [ ] DELETE OR COMMENT OUT THE SECTION YOU WONT BE USING
## create a categorical variable for plotting
max_ar    <- max(ar$`Upper 95%CI`, na.rm = TRUE) # define your highest AR
breakers <- as.integer(c(0, # include zero as a standalone group
seq(1, max_ar, by = max_ar/4) # 1 to maximum with four divisions
))
## add a categorical variable using the age_categories function
## nb in this case we arent using ages - but it functions the same way!
ar <- mutate(ar,
categories = age_categories(`AR (per 100,000)`,
breakers = breakers)
)
## join your ar or case counts based on matching shapefile names with regions in your ar table
mapsub <- left_join(map, ar, by = c("name" = "Region"))
## plotting with polygons ------------------------------------------------------
## choropleth
## you could also fill by cases using `Cases (n)` in the fill option instead of `AR (per 100,000)`
ggplot() +
geom_sf(data = mapsub, aes(fill = categories), col = "grey50") + # shapefile as polygon
coord_sf(datum = NA) + # needed to avoid gridlines being drawn
annotation_scale() + # add a scalebar
# color the scale to be perceptually uniform
# drop FALSE keeps all levels
# name allows you to change the legend title
scale_fill_viridis_d(drop = FALSE, option = "C", name = "AR (per 100,000)") +
geom_sf_text(data = mapsub, aes(label = name), colour = "grey50") + # label polygons
theme_void() # remove coordinates and axes
## plotting with points --------------------------------------------------------
# ggplot() +
#   # plot shapefile as point
#   # shape 21 allows fill variable and colour border (e.g. black ring around circle)
#   # size allows you to make it bigger
#   geom_sf(data = mapsub, aes(fill = categories), shape = 21, size = 5, color = "black") +
#   coord_sf(datum = NA) + # needed to avoid gridlines being drawn
#   annotation_scale() + # add a scalebar
#   scale_fill_viridis_d(drop = FALSE, option = "C") + # color the scale to be perceptually uniform
#   theme_void() # remove coordinates and axes
## Checklist for plotting in for-loop ------------------------------------------
## - [ ] decide if you would like to show counts, AR or categories of those
## - [ ] define appropriate breaks to ensure legend is uniform by week
## - [ ] replace `Cases (n)` and `AR (per 100,000)` or "categories", appropriately
## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)
# change region variable to a factor so that zero counts can be included
linelist_cleaned$patient_origin <- as.factor(linelist_cleaned$patient_origin)
# case counts
cases <- linelist_cleaned %>%
group_by(epiweek) %>%
count(patient_origin, .drop = FALSE) %>%   # cases for each week by region
left_join(population_data_region, by = "patient_origin")    # merge population data
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>%
# add the region column to table
bind_cols(select(cases, epiweek, patient_origin), .) %>%
rename("Region" = patient_origin,
"Cases (n)" = cases,
"Population" = population,
"AR (per 100,000)" = ar,
"Lower 95%CI" = lower,
"Upper 95%CI" = upper)
max_cases <- max(cases$n, na.rm = TRUE) # define the maximum number of cases for the color palette
max_ar    <- max(ar$`Upper 95%CI`, na.rm = TRUE)
## define breaks for standardising color palette
breakers <- as.integer(c(0, # include zero as a standalone group
find_breaks(max_ar, breaks = 4, snap = 100) # four breaks rounded to nearest 100
))
## add a categorical variable using the age_categories function
## nb in this case we arent using ages - but it functions the same way!
ar <- mutate(ar,
categories = age_categories(`AR (per 100,000)`,
breakers = breakers)
)
# go through each epiweek, fiter and plot the data
for (i in unique(cases$epiweek)) {
this_ar <- filter(ar, epiweek == i)
# map
mapsub <- left_join(map, this_ar, by = c("name" = "Region"))
# choropleth
map_plot <- ggplot() +
geom_sf(data = mapsub, aes(fill = categories), col = "grey50") + # shapefile as polygon
coord_sf(datum = NA) + # needed to avoid gridlines being drawn
annotation_scale() + # add a scalebar
scale_fill_viridis_d(drop = FALSE, option = "C",
name = "AR (per 100,000)") + # color the scale to be perceptually uniform (keep levels)
theme_void() # remove coordinates and axes
# plot with the region on the x axis sorted by increasing ar
# ar value on the y axis
barplot <- ggplot(this_ar, aes(x = reorder(Region, `AR (per 100,000)`),
y = `AR (per 100,000)`)) +
geom_bar(stat = "identity", col = "black", fill = "red") + # plot as bars (identity = as is)
geom_errorbar(aes(ymin = `Lower 95%CI`, ymax = `Upper 95%CI`), width = 0.2) + # add CIs
scale_y_continuous(expand = c(0, 0), limits = c(0, max_ar)) +  # set origin for axes
# add labels to axes and below chart
labs(x = "Region", y = "AR (per 100,000)",
captions = paste0("Source: MSF data from ", reporting_week)) +
epicurve_theme
# combine the barplot and map plot into one
print(
cowplot::plot_grid(
barplot + labs(title = paste0("Epiweek:", i)),
map_plot,
nrow = 1,
align = "h",
axis = "tb"
)
)
}
blogdown::new_content(training/AJS_Walkthrough_Cleaning)
blogdown::new_content("training/AJS_Walkthrough_Cleaning.Rmd", kind = "page")
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE,       # hide all code chunks in output
error = TRUE,       # show errors if they appear, but don't stop
fig.width = 6*1.25, # Figure width
fig.height = 6      # Figure height
)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")
# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
"dplyr",       # clean/shape data
"forcats",     # clean/shape data
"ggplot2",     # create plots and charts
"sitrep",      # MSF field epi functions
"linelist",    # Functions for cleaning/standardising data
"incidence",   # create epicurves
"aweek",       # define epi weeks
"epitools",    # 2x2 tables and other epi goodness
"sf",          # encode spatial vector data
"ggspatial")   # plot maps
for (pkg in required_packages) {
# install packages if not already present
if (!pkg %in% rownames(installed.packages())) {
install.packages(pkg)
}
# load packages to this current session
library(pkg, character.only = TRUE)
}
# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday)
aweek::set_week_start("Monday")
# creates object linelist_dict using the msf_dict function from the sitrep package
# View the data dictionary by clicking
linelist_dict <- msf_dict("AJS", compact = FALSE) %>%
select(option_code, option_name, everything())
View(linelist_dict)
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("public/training/AJS_AmTiman", which = "linelist")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/public/training/AJS_AmTiman", which = "linelist")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/public/training/AJS_AmTiman.xlsx", which = "linelist")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/public/training/AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/static/data/AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/data/AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/data/AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("/data/AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- choose.files()
# linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- choose.files()
# linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- choose.files()
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
linelist_raw <- NA
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx")
View(linelist_raw)
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = TRUE,       # hide all code chunks in output
error = TRUE,       # show errors if they appear, but don't stop
fig.width = 6*1.25, # Figure width
fig.height = 6      # Figure height
)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")
# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
"dplyr",       # clean/shape data
"forcats",     # clean/shape data
"ggplot2",     # create plots and charts
"sitrep",      # MSF field epi functions
"linelist",    # Functions for cleaning/standardising data
"incidence",   # create epicurves
"aweek",       # define epi weeks
"epitools",    # 2x2 tables and other epi goodness
"sf",          # encode spatial vector data
"ggspatial")   # plot maps
for (pkg in required_packages) {
# install packages if not already present
if (!pkg %in% rownames(installed.packages())) {
install.packages(pkg)
}
# load packages to this current session
library(pkg, character.only = TRUE)
}
# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday)
aweek::set_week_start("Monday")
# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming
# for example it changes spaces and dots to "_" and characters to lowercase
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
# overwrite variable names with defined clean names
# colnames(linelist_cleaned) <- cleaned_colnames
cleaned_colnames
msf_dict_rename_helper("AJS")
## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw
# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming
# for example it changes spaces and dots to "_" and characters to lowercase
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
# overwrite variable names with defined clean names
colnames(linelist_cleaned) <- cleaned_colnames
View(linelist_cleaned)
blogdown::serve_site()
blogdown::serve_site()
2+2
