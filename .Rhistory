## function. In this example, we have the columns "gender" and "age" that we
## want to rename as "sex" and "age_years".
## The formula for this is rename(data, NEW_NAME = OLD_NAME).
# linelist_cleaned <- rename(linelist_cleaned,
#                            gender    = sex, # TEXT
#                            age_years = age  # INTEGER_POSITIVE
# )
## You can use the function msf_dict_rename_helper() to create a template based
## on the AJS dictionary.
# This will copy a rename command like the one above
## to your clipboard.
msf_dict_rename_helper("AJS")
## Paste the result here and add add the column names from linelist_cleaned
## to the appropriate variables. PLEASE NOTE: this is not a foolproof solution;
## you still need to be aware of what each variable means and what values it
## takes.
##
## If there are any variables that are in the MSF dictionary that are not in
## your data set, then you should comment them out, but be aware that some
## analyses may not run because of this.
## OPTIONAL: if you only want to keep certain variables -
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables
# linelist_cleaned <- select(linelist_cleaned, c(1:3, "age_years", "sex")
## Add the appropriate column names after the equals signs
linelist_cleaned <- rename(linelist_cleaned,
#  event_file_type                   =   , # TEXT                # (Not in dataset)
case_number                       =   hevid, # TEXT
date_of_admission                 =   dtmedical, # DATE
detected_by                       =   referredby, # TEXT
# patient_facility_type             =   , # TEXT                # (Not in dataset)
#  msf_involvement                   =   , # TEXT                # (Not in dataset)
age_years                         =   age, # INTEGER_POSITIVE
#  age_months                        =   , # INTEGER_POSITIVE   # (Dataset only has years)
#  age_days                          =   , # INTEGER_POSITIVE   # (Dataset only has years)
sex                               =   sex, # TEXT
patient_origin                    =   quartier, # ORG UNIT
#  residential_status_brief          =   , # TEXT               # (Not in dataset)
#  arrival_date_in_area_if_3m        =   , # DATE               # (Not in dataset)
#  ever_received_hepatitis_e_vaccine =   , # TEXT               # (Not in dataset)
#  date_of_last_vaccination          =   , # DATE               # (Not in dataset)
date_of_onset                     =   dtjaundice, # DATE
#  history_of_fever                  =   , # BOOLEAN            # (Not in dataset)
fever                             =   medfever, # BOOLEAN
nausea_anorexia                   =   mednausea, # BOOLEAN
vomiting                          =   medvomit, # BOOLEAN
epigastric_pain_heartburn         =   medepigastric, # BOOLEAN
generalized_itch                  =   meditching, # BOOLEAN
headache                          =   medheadache, # BOOLEAN
joint_pains                       =   medarthralgia, # BOOLEAN
diarrhoea                         =   meddiar, # BOOLEAN
bleeding                          =   medbleeding, # BOOLEAN
#  convulsions                       =   , # BOOLEAN            # (Not in dataset)
mental_state                      =   medmental, # BOOLEAN    # !(Needs value cleaning)
other_symptoms                    =   medother, # BOOLEAN
other_cases_in_hh                 =   medothhhajs, # BOOLEAN
#  traditional_medicines             =   , # BOOLEAN            # (Not in dataset)
#  traditional_medicine_details      =   , # TEXT               # (Not in dataset)
#  recent_travel                     =   , # BOOLEAN            # (Not in dataset)
#  water_source                      =   , # TEXT               # !(Split across many variables)
malaria_rdt_at_admission          =   medmalrdt, # TEXT
hep_b_rdt                         =   medhepb, # TEXT
hep_c_rdt                         =   medhepc, # TEXT
hep_e_rdt                         =   medhevrdt, # TEXT
#  dengue_rdt                        =   , # TEXT               # (Not in dataset)
date_lab_sample_taken             =   medblooddt, # DATE
test_hepatitis_a                  =   medhavelisa, # TEXT
test_hepatitis_b                  =   medhbvelisa, # TEXT
test_hepatitis_c                  =   medhcvelisa, # TEXT
test_hepatitis_e_virus            =   medhevelisa, # TEXT
test_hepatitis_e_igm              =   hevrecent, # TEXT
#  test_hepatitis_e_igg              =   , # TEXT               # (In same variable as elisa result)
test_hepatitis_e_genotype         =   hevgenotype, # TEXT
#  malaria_blood_film                =   , # TEXT               # (Not in dataset)
dengue                            =   dengue, # TEXT
yellow_fever                      =   yf, # TEXT
#  lassa_fever                       =   , # TEXT               # (Not in dataset)
#  typhoid                           =   , # TEXT               # (Not in dataset)
chikungunya_onyongnyong           =   chik, # TEXT
#  ebola_marburg                     =   , # TEXT               # (Not in dataset)
other_arthropod_transmitted_virus =   arbovpcr, # TEXT
#  other_pathogen                    =   , # TEXT               # (Not in dataset)
#  lab_comments                      =   , # TEXT               # (Not in dataset)
pregnant                          =   medpreg, # TEXT
trimester                         =   medpregtri, # TEXT
#  foetus_alive_at_admission         =   , # TEXT               # (Not in dataset)
#  delivery_event                    =   , # TRUE_ONLY          # (Not in dataset)
pregnancy_outcome_at_exit         =   medppoutcome, # TEXT
exit_status                       =   outcomehp, # TEXT
#  date_of_exit                      =   , # DATE               # (Not in dataset)
#  time_to_death                     =   , # TEXT               # (Not in dataset)
treatment_facility_site           =   hpid # TEXT
#  treatment_location                =   , # ORGANISATION_UNIT  # (Not in dataset)
#  patient_origin_free_text          =    # TEXT
)
population_data <- rio::import("C:/Users/Neale/OneDrive - Neale Batra/Desktop/R4EPIs-website2/content/training/AJS_AmTiman_population_revised_for_template.xlsx", which = "quartier")
## Browsing data ---------------------------------
## here are a few ways to do data explorations
## view the first ten rows of data
head(linelist_cleaned, n = 10)
## view your whole dataset interactivley (in an excel style format)
## Remember that `View` needs to be written with a capital *V*
View(linelist_cleaned)
## overview of variable types and contents
str(linelist_cleaned)
## gives mean, median and max values of variables
## gives counts for categorical variables
## also gives number of NAs
summary(linelist_cleaned)
## view unique values contained in variables
unique(linelist_cleaned$sex)
## another alternative is with the "summarytools package"
## use the dfSummary function in combination with view
## note that view is not capitalised with this package
# install.packages("summarytools")
# summarytools::view(summarytools::dfSummary(linelist_cleaned))
# Date variables ---------------------------------
# IF YOU ARE USING THE DATA DICTIONARY USE THIS OTHERWISE UNCOMMENT LINES BELOW
# make sure all date variables are formatted as dates
DATEVARS <- filter(linelist_dict, data_element_valuetype == "DATE") %>%
select(data_element_shortname) # select date vars
View(DATEVARS)
# change to dates
linelist_cleaned <- linelist_cleaned %>%
mutate_at(DATEVARS$data_element_shortname, as.Date)
# if you dont have a data dictionary you could do it this way too
linelist_cleaned <- linelist_cleaned %>%
mutate_at(vars(matches("date|Date")), as.Date)
vars()
matches("date|Date")
linelist_cleaned <- linelist_cleaned %>%
mutate_at(DATEVARS$data_element_shortname, as.Date)
mutate_at(DATEVARS$data_element_shortname, linelist::guess_dates,
error_tolerance = 0.5)
mutate_at(DATEVARS$data_element_shortname, linelist::guess_dates,
error_tolerance = 0.5)
# if you dont have a data dictionary you could do it this way too
linelist_cleaned <- linelist_cleaned %>%
mutate_at(vars(matches("date|Date")), linelist::guess_dates,
error_tolerance = 0.5)
View(linelist_cleaned)
class(linelist_cleaned$dateentry)
class(linelist_cleaned$dthospitalisation)
# Use this if your dataset does not align with the data dictionary
linelist_cleaned <- linelist_cleaned %>%
mutate_at(vars(matches("date|Date|dt")), linelist::guess_dates,
error_tolerance = 0.5)
#if you dont have a data dictionary you could do it this way too
linelist_cleaned <- linelist_cleaned %>%
mutate_at(vars(matches("date|Date|dt")), linelist::guess_dates,
error_tolerance = 0.5)
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE,       # hide all code chunks in output
error = TRUE,       # show errors if they appear, but don't stop
fig.width = 6*1.25, # Figure width
fig.height = 6      # Figure height
)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")
# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
"dplyr",       # clean/shape data
"forcats",     # clean/shape data
"ggplot2",     # create plots and charts
"sitrep",      # MSF field epi functions
"linelist",    # Functions for cleaning/standardising data
"incidence",   # create epicurves
"aweek",       # define epi weeks
"epitools",    # 2x2 tables and other epi goodness
"sf",          # encode spatial vector data
"ggspatial")   # plot maps
for (pkg in required_packages) {
# install packages if not already present
if (!pkg %in% rownames(installed.packages())) {
install.packages(pkg)
}
# load packages to this current session
library(pkg, character.only = TRUE)
}
# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday)
aweek::set_week_start("Monday")
# If your linelist is an excel export of data from DHIS2 use this code chunk
# This assumes your data fits the standardised MSF data dictionary for this
# disease (Otherwise use one of the code chunks below for csv DHIS data and for
# non DHIS data). This script is adapted to fit to DHIS standardised data.
# If you don't have lab tests or do not wish to create a case definition,
# then you will need to fix code stratified by case definition later in the script
## Read data ------------------------------------------------------
# USE ONE OF THE BELOW TWO OPTIONS TO READ IN YOUR DATA FROM EXCEL
# one version is for password protected files
## Excel file ---------------------------
#
## To read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
## Excel file (password-protected) ------
#
## Use the excel.link package
# library(excel.link)
# linelist_raw <- xl.read.file("linelist.xlsx",
#                              xl.sheet = "Sheet1",
#                              password = askpass::askpass(prompt = "please enter file password"))
## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
#linelist_raw <- gen_data("AJS") # generates a fake dataset for use as an example in this template
## MSF AJS Dictionary ---------------
## The data dictionary has variable names in the data_element_shortname column.
## Possible values for each variable are specified in the Code and Name columns.
## Where code has the shortened values and name has the full text values.
## get MSF data dictionary for AJS
linelist_dict <- msf_dict("AJS", compact = FALSE) %>%
select(option_code, option_name, everything())
## you can look at the standard dictionary by uncommenting the line below
# View(linelist_dict)
## you can view variable names in the standard data dicationry uncommenting the line below
# linelist_dict$data_element_shortname
# Clean column names ---------------------------------------------
## a good first step is to assign standard column names so that subsequent code
## uses stable column names. In case the input data changes, you just need to
## fix the column mapping.
## make a copy of your orginal dataset and name it linelist_cleaned
#linelist_cleaned <- linelist_raw
## UNCOMMENT AND RUN TWO LINES OF CODE BELOW!
##
## define clean variable names using clean_labels from the epitrix package. This
## function defines rules for variable naming; for example, it changes spaces
## and dots to "_" and sets all characters to lowercase.
# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
# colnames(linelist_cleaned) <- cleaned_colnames # overwrite variable names with defined clean names
## OPTIONAL: below is just an example in case you want to specifically change a
## few names you can also change specific var names using the *rename*
## function. In this example, we have the columns "gender" and "age" that we
## want to rename as "sex" and "age_years".
## The formula for this is rename(data, NEW_NAME = OLD_NAME)
# linelist_cleaned <- rename(linelist_cleaned,
#                            gender    = sex,
#                            age_years = age)
## OPTIONAL: if you only want to keep certain variables -
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables
# linelist_cleaned <- select(linelist_cleaned, c(1:3, "age_years", "sex")
## Standardising values --------------------------------------------
##
## Data entered in through software will often code values in a compact format
## to save space. For example, Yes/No values will often be coded as 1 or 0 and
## sex coded as M or F. This line uses the MSF dictionary to recode these values
## back to a human-readable format.
#linelist_cleaned <- clean_variable_spelling(linelist_cleaned,
#                                            wordlists = filter(linelist_dict, !is.na(option_code)),
#                                            spelling_vars = "data_element_shortname",
#                                            sort_by = "option_order_in_set"
#                                           )
# If your linelist is a csv export of data from DHIS2 use this code chunk
# This assumes your data fits the standardised MSF data dictionary for this disease
## Read data ------------------------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
## get MSF data dictionary for AJS
# linelist_dict <- msf_dict("AJS")
## Fixing variable names ----------------------
## make a copy of your original dataset and name it linelist_cleaned
# linelist_cleaned <- linelist_raw
## define clean variable names using clean_labels from the epitrix package
# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
## overwrite variable names with excel version names from data dictionary
## return which rows in the data dictionary match your column names
# match_cols <- match(cleaned_colnames, linelist_dict$data_element_name, nomatch = 0)
# cleaned_colnames[match_cols > 0] <- linelist_dict$data_element_shortname[match_cols]
## overwrite variable names with defined clean names
# colnames(linelist_cleaned) <- cleaned_colnames
## Standardising values --------------------------------------------
##
## Data entered in through software will often code values in a compact format
## to save space. For example, Yes/No values will often be coded as 1 or 0 and
## sex coded as M or F. This line uses the MSF dictionary to recode these values
## back to a human-readable format.
## linelist_cleaned <- switch_vals(df = linelist_cleaned, disease = "AJS")
## IF YOUR LINELIST NOT AN EXPORT OF DATA FROM DHIS2 USE THIS CODE CHUNK ------
##
## This assumes your data does not fit the standardised MSF data dictionary for
## this disease. If you are using this section, be aware that this template may
## not work simply due to the unpredictable nature of non-standardized data
##
## Checklist to clean and update this script to match your data ---------------
##
## - [ ] Recode your variable names to match this analysis
## - [ ] Recode variable contents
## - [ ] Check the code later in the script and update it to fit your names/contents
## - [ ] Make sure to comment out all lines in read_DHIS_excel_data chunk
##
## You will still need to read in the standardised data dictionary
##   This is to understand which variables are being used later in the script
##   So that you can adapt those later code chunks to fit your dataset.
## The data dictionary has variable names in the data_element_shortname column.
## Possible values for each variable are specified in the Code and Name columns.
## Where code has the shortened values and name has the full text values.
##
## - [ ] run this to look at the data dictionary:
# linelist_dict <- msf_dict("AJS")
# View(linelist_dict)
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist", na = ".")
#
# For password protected Excel file
# use the excel.link package
# library(excel.link)
# linelist_raw <- xl.read.file("linelist.xlsx",
#                              xl.sheet = "Sheet1",
#                              password = askpass::askpass("please enter file password"))
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")
## Fixing variable names ----------------------
## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw
# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming
# for example it changes spaces and dots to "_" and characters to lowercase
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
# overwrite variable names with defined clean names
colnames(linelist_cleaned) <- cleaned_colnames
## Renaming variables to match the template -------------------------------
## OPTIONAL: below is just an example in case you want to specifically change a
## few names you can also change specific var names using the *rename*
## function. In this example, we have the columns "gender" and "age" that we
## want to rename as "sex" and "age_years".
## The formula for this is rename(data, NEW_NAME = OLD_NAME).
# linelist_cleaned <- rename(linelist_cleaned,
#                            gender    = sex, # TEXT
#                            age_years = age  # INTEGER_POSITIVE
# )
## You can use the function msf_dict_rename_helper() to create a template based
## on the AJS dictionary.
# This will copy a rename command like the one above
## to your clipboard.
msf_dict_rename_helper("AJS")
## Paste the result here and add add the column names from linelist_cleaned
## to the appropriate variables. PLEASE NOTE: this is not a foolproof solution;
## you still need to be aware of what each variable means and what values it
## takes.
##
## If there are any variables that are in the MSF dictionary that are not in
## your data set, then you should comment them out, but be aware that some
## analyses may not run because of this.
## OPTIONAL: if you only want to keep certain variables -
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables
# linelist_cleaned <- select(linelist_cleaned, c(1:3, "age_years", "sex")
## Add the appropriate column names after the equals signs
linelist_cleaned <- rename(linelist_cleaned,
#  event_file_type                   =   , # TEXT                # (Not in dataset)
case_number                       =   hevid, # TEXT
date_of_admission                 =   dtmedical, # DATE
detected_by                       =   referredby, # TEXT
# patient_facility_type             =   , # TEXT                # (Not in dataset)
#  msf_involvement                   =   , # TEXT                # (Not in dataset)
age_years                         =   age, # INTEGER_POSITIVE
#  age_months                        =   , # INTEGER_POSITIVE   # (Dataset only has years)
#  age_days                          =   , # INTEGER_POSITIVE   # (Dataset only has years)
sex                               =   sex, # TEXT
patient_origin                    =   quartier, # ORG UNIT
#  residential_status_brief          =   , # TEXT               # (Not in dataset)
#  arrival_date_in_area_if_3m        =   , # DATE               # (Not in dataset)
#  ever_received_hepatitis_e_vaccine =   , # TEXT               # (Not in dataset)
#  date_of_last_vaccination          =   , # DATE               # (Not in dataset)
date_of_onset                     =   dtjaundice, # DATE
#  history_of_fever                  =   , # BOOLEAN            # (Not in dataset)
fever                             =   medfever, # BOOLEAN
nausea_anorexia                   =   mednausea, # BOOLEAN
vomiting                          =   medvomit, # BOOLEAN
epigastric_pain_heartburn         =   medepigastric, # BOOLEAN
generalized_itch                  =   meditching, # BOOLEAN
headache                          =   medheadache, # BOOLEAN
joint_pains                       =   medarthralgia, # BOOLEAN
diarrhoea                         =   meddiar, # BOOLEAN
bleeding                          =   medbleeding, # BOOLEAN
#  convulsions                       =   , # BOOLEAN            # (Not in dataset)
mental_state                      =   medmental, # BOOLEAN    # !(Needs value cleaning)
other_symptoms                    =   medother, # BOOLEAN
other_cases_in_hh                 =   medothhhajs, # BOOLEAN
#  traditional_medicines             =   , # BOOLEAN            # (Not in dataset)
#  traditional_medicine_details      =   , # TEXT               # (Not in dataset)
#  recent_travel                     =   , # BOOLEAN            # (Not in dataset)
#  water_source                      =   , # TEXT               # !(Split across many variables)
malaria_rdt_at_admission          =   medmalrdt, # TEXT
hep_b_rdt                         =   medhepb, # TEXT
hep_c_rdt                         =   medhepc, # TEXT
hep_e_rdt                         =   medhevrdt, # TEXT
#  dengue_rdt                        =   , # TEXT               # (Not in dataset)
date_lab_sample_taken             =   medblooddt, # DATE
test_hepatitis_a                  =   medhavelisa, # TEXT
test_hepatitis_b                  =   medhbvelisa, # TEXT
test_hepatitis_c                  =   medhcvelisa, # TEXT
test_hepatitis_e_virus            =   medhevelisa, # TEXT
test_hepatitis_e_igm              =   hevrecent, # TEXT
#  test_hepatitis_e_igg              =   , # TEXT               # (In same variable as elisa result)
test_hepatitis_e_genotype         =   hevgenotype, # TEXT
#  malaria_blood_film                =   , # TEXT               # (Not in dataset)
dengue                            =   dengue, # TEXT
yellow_fever                      =   yf, # TEXT
#  lassa_fever                       =   , # TEXT               # (Not in dataset)
#  typhoid                           =   , # TEXT               # (Not in dataset)
chikungunya_onyongnyong           =   chik, # TEXT
#  ebola_marburg                     =   , # TEXT               # (Not in dataset)
other_arthropod_transmitted_virus =   arbovpcr, # TEXT
#  other_pathogen                    =   , # TEXT               # (Not in dataset)
#  lab_comments                      =   , # TEXT               # (Not in dataset)
pregnant                          =   medpreg, # TEXT
trimester                         =   medpregtri, # TEXT
#  foetus_alive_at_admission         =   , # TEXT               # (Not in dataset)
#  delivery_event                    =   , # TRUE_ONLY          # (Not in dataset)
pregnancy_outcome_at_exit         =   medppoutcome, # TEXT
exit_status                       =   outcomehp, # TEXT
#  date_of_exit                      =   , # DATE               # (Not in dataset)
#  time_to_death                     =   , # TEXT               # (Not in dataset)
treatment_facility_site           =   hpid # TEXT
#  treatment_location                =   , # ORGANISATION_UNIT  # (Not in dataset)
#  patient_origin_free_text          =    # TEXT
)
## USE THIS TO READ IN POPULATION OR TO CREATE IT FROM PROPORTIONS  -----------
##
## There are two options for using population data here.
## The first one is where you only know the total population number, and the
## proportion breakdown for categories (e.g. by age group, sex or region).
## The second option is to read in population from excel.
## In both cases you will need to make sure that the respective groups for
## population fit the groups in your linelist data set!
##
## Checklist for population data ----------------------------------------------
##
## - [ ] Decide if you have stratified population data available as counts or only proportions
## - [ ] If you have counts available:
##          - [ ] use View on the fake data generated to make sure your format in excel matches
##          - [ ] read in and clean data appropriately in the "Read data" section
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] If have total population and proportion breakdown available:
##          - [ ] use the gen_population function in "counts from populaiton proportions" section
##          - [ ] type in your population, groups, and respective proportions
##          - [ ] group can be any categorical variable you want
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] DELETE OR COMMENT OUT THE UNUSED SECTION
## Read data ------------------------------------
## Excel file
## to read in a specific sheet use "which"
population_data <- rio::import("C:/Users/Neale/OneDrive - Neale Batra/Desktop/R4EPIs-website2/content/training/AJS_AmTiman_population_revised_for_template.xlsx", which = "quartier")
## repeat same cleaning steps as in standardise_clean_data code chunk as appropriate
## make sure your place variable name matches!
## Counts from population proportions ------------------------------------
## if you only know the total population and the proportions in each age group, use this function
# generate population data by region
#population_data_region <- gen_population(total_pop = 5000,         # set the total population
#  groups = c("Village A", "Village B", "Village C", "Village D"),  # set the groups
#  proportions = c(0.221, 0.174, 0.355, 0.245),                     # set the proportions for each group
#  strata = NULL) %>%               # do not stratify by gender
#  rename(patient_origin = groups,  # rename columns (syntax is NEW NAME = OLD NAME)
#         population = n)
# generate population data by age groups in years
#population_data_age <- gen_population(total_pop = 5000,
#  groups = c("0-2", "3-14", "15-29", "30-44", "45+"),
#  proportions = c(0.182, 0.278, 0.26, 0.11, 0.07),
#  strata = NULL) %>%
#  rename(age_group = groups,
#    population = n)
# generate population data by age group in months (under 2 years)
#population_data_age_months <- gen_population(total_pop = 5000,
#  groups = c("0-5", "6-8", "9-11","12-24"),
#  proportions = c(0.278, 0.11, 0.18, 0.26),
#  strata = NULL) %>%
#  rename(age_group_mon = groups,
#    population = n)
# generate population data by age categories in months and years
# population_data_age_categories <- gen_population(total_pop = 5000,
#   groups = c("0-5 months", "6-8 months", "9-11 months","12-24 months",
#              "3-14 years", "15-29 years", "30-44 years", "45+ years"),
#   proportions = c(0.278, 0.11, 0.18, 0.26, 0.278, 0.26, 0.11, 0.07),
#   strata = NULL) %>%
#   rename(age_category = groups,
#     population = n)
## OPTIONAL: this section can be used to read in lab data
## make sure that your unique identifiers (e.g. case_number) match with the linelist!
## - [ ] DELETE THE FAKE DATA SECTION!!
## Read data ------------------------------------
## Excel file
## to read in a specific sheet use "which"
# lab_data <- rio::import("labresults.xlsx", which = "Sheet1")
## repeat same cleaning steps as in standardise_clean_data code chunk as appropriate
## make sure your unique ID variable name matches!
## Fake data ------------------------------------
## THE BELOW CAN BE DELETED IF YOU HAVE YOUR OWN (REAL) LABORATORY DATA!
## its just to be able to demonstrate script in this template
# # generate artificial lab tests results
# lab_results <- linelist_cleaned %>%
#                 select(case_number) %>%
#                 mutate(test_result = sample(c("Positive", "Negative"),
#                                             nrow(linelist_cleaned),
#                                             replace = TRUE)
#                        )
#
# # merging linelist with lab dataset
# linelist_cleaned <- left_join(linelist_cleaned, lab_results,
#                               by = "case_number")
blogdown::stop_server()
