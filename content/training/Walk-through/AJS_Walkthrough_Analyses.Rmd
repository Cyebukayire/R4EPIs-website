---
date: "2019-08-19T09:28:05+02:00"
title: Template Walk-through - Analyses
weight: 9
---


```{r setup, include=FALSE, results='hide', message=FALSE, warning=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = TRUE,       # hide all code chunks in output
                      error = TRUE,       # show errors if they appear, but don't stop
                      fig.width = 6*1.25, # Figure width
                      fig.height = 6      # Figure height
                     )
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")

# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "dplyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "stringr",     # clean text
                       "rio",         # read in data
                       "ggplot2",     # create plots and charts
                       "sitrep",      # MSF field epi functions
                       "linelist",    # Functions for cleaning/standardising data
                       "incidence",   # create epicurves
                       "aweek",       # define epi weeks
                       "epitools",    # 2x2 tables and other epi goodness
                       "epitrix",     # epi helpers and tricks
                       "sf",          # encode spatial vector data
                       "ggspatial")   # plot maps

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}


# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))

# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday) 
aweek::set_week_start("Monday")

reporting_week <- "2017-W52"  # Set the reporting week


# Read in the R object linelist_cleaned that is defined and saved 
# in the AJS_Walkthrough_Cleaning script
linelist_cleaned <- readRDS("data/linelist_cleaned.rds")

population_data_region <- rio::import("AJS_AmTiman_population_revised_for_template.xlsx", which="quartier")

# create a grouping of all symptoms 
SYMPTOMS <- c("generalized_itch", 
#             "history_of_fever", 
              "fever",
              "joint_pains",
              "epigastric_pain_heartburn",
              "nausea_anorexia",
              "vomiting", 
              "diarrhoea",
              "bleeding", 
              "headache",
              "mental_state",
#              "convulsions",
              "other_symptoms"  
              )

# create a grouping of all lab tests 
LABS <- c("hep_b_rdt", 
          "hep_c_rdt",
          "hep_e_rdt",
          "test_hepatitis_a",
          "test_hepatitis_b",
          "test_hepatitis_c",
#          "test_hepatitis_e_igg",
          "test_hepatitis_e_igm" ,
          "test_hepatitis_e_genotype",
          "test_hepatitis_e_virus",
          "malaria_rdt_at_admission",
#          "malaria_blood_film", 
          "dengue",
#          "dengue_rdt", 
          "yellow_fever",
#          "typhoid",
          "chikungunya_onyongnyong", 
#          "ebola_marburg",
#          "lassa_fever",
          "other_arthropod_transmitted_virus" 
#          "other_pathogen"
          )


# define the first week of outbreak (date of first case)
first_week <- levels(linelist_cleaned$epiweek)[1]

# outbreak start 
# return the first day in the week of first case 
obs_start <- week2date(sprintf("%s-1", first_week))

# return last day of reporting week 
obs_end   <- week2date(sprintf("%s-7", reporting_week))

```

```{r}
nrow(linelist_cleaned)
```

After data import and cleaning, the template contains three analytical sections:  

* Person  
* Time  
* Place  



## Person 

TODO [general description of person section]

### Demographic Tables:

The first demographic table presents patients by their age group (the table's rows) and their relationship with the case definition (the table's columns). Arguments row_total and col_total are set to TRUE, resulting in totals shown for rows and columns.  

* The select() command removed an unnecessary column "variable" generated by tab_linelist().  
* The rename() command renames the column "value" with "Age Group"  
* The rename_redundant() command replaces any column name that has proportion with "%"  
* The augment_redundant() command replaces any column name with n with " cases (n)"  
* The kable() command completes the table with two digits after a decimal

**TODO: There seems to still be issues with the new tab_linelist function. Error says object proportion is unknown. Need to resolve and then remove the # from the rename_redundant line below.** 

```{r describe_by_age_group_and_def}
# use if you have lab results in your data
# get counts and props of age groups by case definition 
# include column and row totals 
tab_linelist(linelist_cleaned, 
             age_group, strata = case_def, 
             col_total = TRUE, row_total = TRUE) %>%
  select(-variable) %>%
  rename("Age group" = value) %>%
  rename_redundant("%" = proportion) %>%
  augment_redundant(" cases (n)" = " n$") %>%
  kable(digits = 2)
```

As demonstrated in the subsequent template code, you can change the argument strata = to refer to any number of variables including sex. You can also choose to include or edit the in-line code that gives a count of the missing cases by sex and age_group. 

To show proportions of the total population, use the following code, with the argument prop_total specified as TRUE. 

```{r total_props_agegroup_sex}
tab_linelist(linelist_cleaned, 
             age_group, strata = sex,
             col_total = TRUE, row_total = TRUE, prop_total = TRUE) %>% 
  select(-variable) %>%
  rename("Age group" = value) %>%
#  rename_redundant("%" = proportion) %>%
  augment_redundant(" cases (n)" = " n$") %>%
  kable(digits = 2)
```


### Age pyramid 
To print an age pyramid in your report, use the code below. A few things to note:  

* The **variable for split_by should have two non-missing value options** (e.g. Male or Female, Oui or Non, etc.)  
* The variable names work with or without quotation marks  
* The dashed lines in the bars are the midpoint of the un-stratified age group   
* You can adjust the position of the legend by replacing legend.position = "bottom" with "top", "left", or "right"  
* Read more by searching plot_age_pyramid in the Help tab of the lower-right RStudio pane  

You can make this a pyramid of months by supplying age_group_mon to the age_group argument.  



```{r age_pyramid, warning=FALSE}
# plot age pyramid 
 
plot_age_pyramid(linelist_cleaned, 
                 age_group = "age_group_mon", 
                 split_by = "sex") + 
  labs(y = "Cases (n)", x = "Age group") + # change axis  labels (nb. x/y flip)
  theme(legend.position = "bottom",     # move legend to bottom
        legend.title = element_blank(), # remove title
        text = element_text(size = 18)  # change text size
       )
```




```{r describe_by_symptoms}
# get counts and proportions for all variables named in SYMPTOMS
tab_linelist(linelist_cleaned, SYMPTOMS, keep = "Yes") %>% 
  select(-value) %>%
  # fix the way symptom names are displayed
  mutate(variable = str_to_sentence(gsub("_", " ", variable))) %>%
  # rename accordingly
  rename_redundant("%" = proportion) %>%
  augment_redundant(" (n)" = " n$") %>%
  kable(digits = 2)
```

```{r describe_by_labs}
# get counts and proportions for all variables named in LABS
multi_descriptive(linelist_cleaned, LABS, .id = "Lab test") %>% 
  # re-order columns (drop total_prop too)
  select("Lab test", Pos_n, Positive_prop, Neg_n, Negative_prop, 
         "Not done_n", "Not done_prop", Total_n) %>% 
  # rename accordingly
  rename("Unknown (n)" = "Not done_n") %>%
  rename_redundant("prop" = "%") %>%
  augment_redundant("_n$" = " (n)") %>%
  kable(digits = 2)

```

## CFR Section

Time to death not applicable. 



The case fatality ratio among inpatients with known outcomes is below.



Case Fatality Ratio - note that this requires there to be a variable patient_facilit_type, the value "Inpatient", and the DIED variable created earlier. 

```{r overall_cfr, warning = FALSE, message = FALSE}
# use arguments from above to produce overal CFR
overall_cfr <- linelist_cleaned %>% 
  filter(patient_facility_type == "Inpatient") %>%
  case_fatality_rate_df(deaths = DIED, mergeCI = TRUE) %>%
  rename("Deaths" = deaths,
         "Cases" = population,
         "CFR (%)" = cfr,
         "95%CI" = ci)

  knitr::kable(overall_cfr, digits = 2)         # print nicely with 2 digits
```



We can also do CFR by sex

```{r cfr_by_sex, warning = FALSE, message = FALSE}
linelist_cleaned %>%
  filter(patient_facility_type == "Inpatient") %>%
  mutate(sex = forcats::fct_explicit_na(sex, "-")) %>%
  case_fatality_rate_df(deaths = DIED, group = sex, mergeCI = TRUE, add_total = TRUE) %>%
  rename("Sex" = sex, 
         "Deaths" = deaths, 
         "Cases" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2)
```


...and by age_group:


CFR by age group among inpatients with known outcomes

```{r cfr_by_age_group, warning = FALSE, message = FALSE}

linelist_cleaned %>%
  filter(patient_facility_type == "Inpatient") %>%
  case_fatality_rate_df(deaths = DIED, group = age_group, mergeCI = TRUE, add_total = TRUE) %>%
  tidyr::complete(age_group, 
                  fill = list(deaths = 0, population = 0, cfr = 0, ci = 0)) %>% # Ensure all levels are represented
  rename("Age Group" = age_group, 
         "Deaths" = deaths, 
         "Cases" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2)
```


CFR by case definition (not enough to do)

```{r cfr_by_case_def, warning = FALSE, message = FALSE}
# Use if you have enough confirmed cases for comparative analysis 
#
 linelist_cleaned %>%
   filter(patient_facility_type == "Inpatient") %>%
   case_fatality_rate_df(deaths = DIED, group = case_def, mergeCI = TRUE, add_total = TRUE) %>%
   rename("Case Definition" = case_def, 
          "Deaths" = deaths, 
          "Cases" = population, 
          "CFR (%)" = cfr, 
          "95%CI" = ci) %>% 
   knitr::kable(digits = 2)
```


## Attack Rate
To use the attack rate section, we need to modify the first code slightly. An object "population" is created from the sum of population counts in the population figures. Because we only imported region-based population counts, we must change this command to reflect that we do not have population_data_age, but rather population_data_region

```{r eval=FALSE}
# OLD define population 
# population <- sum(population_data_age$population)
```

Running the correct command and printing the value of population, we see that the sum population across regions is estimated to be 62336.
```{r}
# Correct command for this exercise
population <- sum(population_data_region$population)

population
```

Below gives the attack rate per 10,000 population (N = `r format(population, big.mark = ",")`)
```{r attack_rate}
# calculate the ar
# store as AR to be able to use output for automating text below (inline functions)
ar <- attack_rate(nrow(linelist_cleaned), population, multiplier = 10000)

ar %>%
  merge_ci_df(e = 3) %>% # merge the lower and upper CI into one column
  rename("Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  select(-Population) %>% # drop the population column as it is not changing
  knitr::kable(digits = 2, align = "r")
```

We are unable to calculate the attack rate by age group, because we do not have population counts for each age group.

Mortality attributable to AJS - not appropriate for this example because...




## Time

```{r create_incidence, message = FALSE}
# This code creates case counts for each week of your outbreak, overall
# As with aweek, you can change the start of your week to e.g. "Sunday week"
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = "Monday week")

# this sets the theme in ggplot for epicurves
epicurve_theme <- theme(
  axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
  legend.title = element_blank(),
  panel.grid.major.x = element_line(color = "grey60", linetype = 3),
  panel.grid.major.y = element_line(color = "grey60", linetype = 3)
)
# This sets the labels in ggplot for the epicurves
epicurve_labels <- labs(x = "Calendar week", 
                        y = "Cases (n)", 
                        title = "Cases by week of onset",
                        subtitle = sprintf("Source: MSF data from %s", reporting_week)
                       ) 
```


```{r epicurve, message = FALSE}
# plot your epicurve as a ggplot (incidence::plot is different to base::plot)
basic_curve <- plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  # add labels to axes and below chart
  epicurve_labels +
  # change visuals of dates and remove legend title
  epicurve_theme

# show your plot (stored for later use) 
basic_curve
basic_curve + scale_x_incidence(inc_week_7, n_breaks = 6)
```


Other possible variants on the epi curve:  
* Option 1  
* Option 2  
* Option 3  


The below gives the attack rate per week. 

```{r attack_rate_per_week, warning = FALSE, message = FALSE}
# counts and cumulative counts by week
cases <- linelist_cleaned %>%
  arrange(date_of_onset) %>%        # arrange by date of onset
  count(epiweek, .drop = FALSE) %>% # count all epiweeks and include zero counts
  mutate(cumulative = cumsum(n))    # add a cumulative sum

# attack rate for each week
ar <- attack_rate(cases$n, population, multiplier = 100000) %>% 
  bind_cols(select(cases, epiweek), .) # add the epiweek column to table

ar %>%
  merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```

And cumulatively:  


```{r cumulative_attack_rate_per_week}
# cumulative attack rate by week
attack_rate(cases$cumulative, population, multiplier = 100000) %>% 
  bind_cols(select(cases, epiweek), .) %>% # add the epiweek column to table
  merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```

```{r cfr_per_week, warning = FALSE, message = FALSE}
# group by known outcome and case definition 
cfr <- linelist_cleaned %>%
  filter(patient_facility_type == "Inpatient") %>%
  case_fatality_rate_df(grepl("Dead", exit_status), group = epiweek)

cfr %>%
  merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
  rename("Epiweek" = epiweek, 
         "Deaths" = deaths, 
         "Cases" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```

You could plot the AR (in the population) and CFR (among inpatients only) together as line graphs by epiweek. 

```{r ar_line_graph}
ar_plot <- ggplot(ar, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              color = "blue", fill = "blue", linetype = 2, alpha = 0.2, show.legend = FALSE) +
  geom_line(aes(y = ar), color = "blue", show.legend = FALSE) +
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  # scale the x axis the same as the incidence curve. Expand forces it to align. 
  incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "AR [95% CI]", subtitle = "Attack Rate (per 100,000)") + 
  # change visuals of dates and remove legend title
  epicurve_theme
```

To plot CFR you must first make the CFR table using above code

```{r cfr_line_graph}
cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
  geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  # scale the x axis the same as the incidence curve. Expand forces it to align. 
  incidence::scale_x_incidence(inc_week_7, n_breaks = nrow(inc_week_7), expand = c(0, 7 * 1.5)) +
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "CFR [95% CI]", 
       subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") + 
  # change visuals of dates and remove legend title
  epicurve_theme 

```


You could then also add the AR and CFR by week on to an epicurve. 

```{r epicurve_ar_cfr, message = FALSE, fig.height = 10}
nofx <- theme(axis.text.x = element_blank(),
              axis.title.x = element_blank())
cowplot::plot_grid(
  basic_curve + nofx,
  ar_plot + nofx,
  cfr_plot,
  align = "v", # align plots vertically
  axis = "lr", # only by their left and right margins
  ncol = 1     # allow only one column
)
```


more optins...



## Place


Basic descriptive table:

```{r describe_by_region_facility}
# get counts and props of region by facility 
# include column and row totals 

descriptive(linelist_cleaned, "patient_origin", 
            "patient_facility_type",
            coltotals = TRUE, rowtotals = TRUE) %>% 
  rename("Region" = "patient_origin") %>%
  augment_redundant("_n$" = " (n)") %>% # modify _n to (n)
  rename_redundant("prop" = "%")    %>% # rename proportions to %
  kable(digits = 2)
```


And attack rates by region.   
Note: changed population_data_region to population_data in line 2.
Error received on left_join: Error in tbl_vars(y) : object 'population_data_region' not found

Then, Error received from merge to create cases. Turns out that in population counts the regions are ALL CAPITALS but in linelist the are lowercase. Need to add line to make that solved.

```{r}
# Converts patient_origin variable to uppercase, to match with population_data
linelist_cleaned$patient_origin <- toupper(linelist_cleaned$patient_origin)
```

Also need fix in proportion() function in sitrep to is.na(n)

```{r attack_rate_by_region}

## - [ ] consider facet wrapping by an overarching unit if have many regions (e.g. by province)


cases <- count(linelist_cleaned, patient_origin) %>%   # cases for each region
  left_join(population_data, by = "patient_origin")    # merge population data 
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100) %>% 
  # add the region column to table
  bind_cols(select(cases, patient_origin), .) %>% 
  rename("Region" = patient_origin, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) 

ar %>% 
  merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column 
  rename("95%CI" = ci) %>%  # rename single 95%CI column
  kable(digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
```


You could then also plot this on a bar chart with confidence intervals. 

```{r bar_attack_rate_by_region}
# plot with the region on the x axis sorted by increasing ar
# ar value on the y axis 
ggplot(ar, aes(x = reorder(Region, `AR (per 100,000)`),
               y = `AR (per 100,000)`)) + 
  geom_bar(stat = "identity", col = "black", fill = "red") + # plot as bars (identity = as is)
  geom_errorbar(aes(ymin = `Lower 95%CI`, ymax = `Upper 95%CI`), width = 0.2) + # add CIs
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Region", y = "AR (per 100,000)", 
       captions = paste0("Source: MSF data from ", reporting_week)) + 
  epicurve_theme
```



Mortality Rates by region
Changed population_data_region to population_data

Changed "Dead" to "Décédé" in grepl


```{r mortality_rate_region}

deaths <- group_by(linelist_cleaned, patient_origin) %>%
  filter(grepl("Décédé", exit_status)) %>% 
  summarise(deaths = n()) %>% # count deaths by region
  left_join(population_data, by = "patient_origin") # merge population data 

mortality_rate(deaths$deaths, deaths$population, multiplier = 10000) %>%
  # add the region column to table
  bind_cols(select(deaths, patient_origin), .) %>% 
  merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
  rename("Region" = patient_origin, 
         "Deaths" = deaths, 
         "Population" = population, 
         "Mortality (per 10,000)" = `mortality per 10 000`, 
         "95%CI" = ci) %>% 
  kable(digits = 2)
```
