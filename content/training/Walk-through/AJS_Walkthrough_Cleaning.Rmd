---
date: "2019-08-05T14:07:44+02:00"
title: Template Walk-through - Data Import and Cleaning
weight: 8
---


```{r setup, include=FALSE, results='hide', message=FALSE, warning=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = TRUE,       # hide all code chunks in output
                      error = TRUE,       # show errors if they appear, but don't stop
                      fig.width = 6*1.25, # Figure width
                      fig.height = 6      # Figure height
                     )
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")

# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "dplyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "stringr",     # clean text
                       "rio",         # read in data
                       "ggplot2",     # create plots and charts
                       "sitrep",      # MSF field epi functions
                       "linelist",    # Functions for cleaning/standardising data
                       "incidence",   # create epicurves
                       "aweek",       # define epi weeks
                       "epitools",    # 2x2 tables and other epi goodness
                       "epitrix",     # epi helpers and tricks
                       "sf",          # encode spatial vector data
                       "ggspatial")   # plot maps

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}


# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))

# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday) 
aweek::set_week_start("Monday")
```

## Overview of this page
This page will demonstrate use of the Acute Jaundice Syndrome (AJS) outbreak template using data from an outbreak in Am Timan, Chad. This first page covers the initial data importation and cleaning steps in the template.  

#### Getting started  

**Getting started with the sitrep package and opening the correct template**
Please review the [getting started page](https://r4epis.netlify.com/welcome/001-getting-started/) for instructions on the following start-up steps:  

* Downloading and configuring R and RStudio  
* Installing the sitrep package  
* Opening an outbreak or survey template  

**Access the datasets for this walk-through**  
[TODO: instructions and link to dataset here]

**Access the final RMarkdown script used in this walk-through**  
[TODO: link to download Chad AJS RMarkdown here]

**RMarkdown resources**  
Review the page "Reading a RMarkdown Script", or reference these resources: [Rmarkdown introduction](https://rmarkdown.rstudio.com/articles_intro.html) and [Rmarkdown authoring basics](https://rmarkdown.rstudio.com/authoring_basics.html).  

  


#### AJS/HEV outbreak in Am Timan, Chad (2016-2017)

We will be using data and examples from a real outbreak of Hepatitis E virus (HEV) infection which occurred in the Chadian town of Am Timan between October 2016 and April 2017  

*DISCLAIMER: The real data from the outbreak has been used for the training materials linked to the outbreak templates of the R4epis project. The Chadian Ministry of Health (MoH) has approved the use of this data for training purposes. Please note, that some data has been adapted in order to best achieve training objectives. Also, the GPS coordinates included in the dataset do not correspond to real cases identified during this outbreak. They have been generated exclusively for training purposes.*  

In early September 2016, a cluster of severely ill pregnant women with jaundice was detected at the Am Timan Hospital in the maternity ward. Following rapid tests conducted in Am Timan and confirmatory testing in the Netherlands, this was confirmed as due to HEV infection. Thus the MoH and MSF outbreak response was activated.  

The response consisted of four components:  

1) active community based surveillance (CBS)  
2) clinical assessment and management of ill cases at the hospital  
3) water chlorination activities at most water points in the town  
4) hygiene promotion  

**The outbreak linelist data was combined data from the active CBS data and the clinical data from the hospital.** The CBS functioned with community health workers visiting all households in the town every two weeks and actively searching for people with Acute Jaundice Syndrome (AJS). For this group of persons (suspected cases), only those that were visibly ill or that were pregnant were referred to the hospital for clinical assessment and admission if required. Persons that self-reported to the hospital or that arrived after referral would undergo a clinical assessment and a rapid test for HEV for diagnosis. Thus only for people assessed at the hospital were we able to capture a confirmed case status.  

For the duration of the outbreak we detected 1193 suspected cases, 100 confirmed cases and discarded 150 cases with AJS who were not positive for HEV infection.  

[Link to publication](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0188240)  

<img src="/images/AJS_Article.png" alt="AJS Article snip", width = "40%">




## Overview of template 

**TODO: Graphic showing big-picture overview of template parts - waiting until final arrangement of chunks in template**

## Header and introduction

The very top of the template consists of a header surrounded by `---` lines. Here you may want to edit the title of your document. The other settings in the header define the default document type produced (Microsoft Word) when the RMarkdown is "knit".

The "Introduction to this template" section is for your information only and this text can be deleted before knitting the document.  

<img src="/images/AJS_Intro.png" alt="AJS Header and Introduction snip", width = "75%">


## Installation and loading packages
**The text which explains the purpose of this code chunk may be deleted, but you must keep the code chunk!** The code will run without producing any output in your final report, but it is required to install (or load using library(), if already installed) the packages necessary to produce the report.  

This "setup" code chunk does the following:  

* Set default settings for tables such as size, error handling, and display of missing values  

* Create a vector of names of packages required for the template to run, each of which is installed if it is not already installed, and then is loaded using library() for use in the current R session.

* Set default text size in graphic plots  

* Set epidemiological weeks to begin on Mondays  

<img src="/images/Package_Installation.png" alt="Package installation chunk snip", width = "75%">


### About the packages used in this template  

#### Generic packages  

* knitr used to create the output document (pdf, doc, html)  
* dplyr used to clean and shape the data  
* forcats used to clean and shape the data  
* stringr used to clean text/characters  
* rio used to read in data  
* epitrix used for data cleaning and variable standardisation  
* ggplot2 used to visualise your data using different plotting methods  

#### More epidemiology-specific packages  

* sitrep includes a variety of useful field epidemiology functions
* linelist used for cleaning and standardising data  
* incidence used for creating epicurves  
* aweek used for creating epiweeks  
* epitools used for creating 2by2 tables  
* epitrix used for helpful epidemiological tasks  

#### Mapping packages  

* ggspatial used for selecting basemap tiles  
* sf used for manipulating spatial objects (e.g. polygons) easily




## Set current epi week  
Set the epidemiological week for the report. **This value is used in later code chunks, for example when producing epidemic curves.** Note that you may want to specify the most recent **complete** epi week. Follow the format in the code below (within quotes give the 4-digit year, a hyphen (-), capital W, then the 2-digit epi week number).  

By default in the templates epi weeks begin on Mondays (this can be changed at the bottom of the "setup" code chunk). See the documentation of the [package "aweek"](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html) for more information. 

To determine which epi week of a date you can use the date2week() function. Let's assume the date of this analysis is 20 April, 2017.

```{r}
date2week("2017-04-20")      #Sys.Date() uses the current date from your computer
```

```{r}
reporting_week <- "2017-W16"  # Set the reporting week
```

## Import the dataset

**In this template section you choose the appropriate code chunk to importing your dataset.** 

<img src="/images/AJS_Data_Import.png" alt="Data import options snip", width = "75%">

For this exercise our dataset is a **non-standardized Excel file** from MSF's response an outbreak of AJS in Am Timan, Chad, so we use the `read_nonDHIS_data` code chunk. We will specifically use the line that uses the import() function of the rio package to import an Excel file that is not password protected. Note that errors can occur if you provide an incorrect file name or path. Tlink for dataset download is at the top of this webpage. 

Either **delete or comment out (#)** all lines of code in the other data import chunks (read_fake_data, read_DHIS_excel_data, and read_DHIS_csv_data).  


```{r eval=FALSE}
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist")
```

There should now be a dataframe object named "linelist_raw" in your environment pane, consisting of 1447 observations and 122 variables.  

<img src="/images/linelist_raw_imported.png" alt="Environment snip with linelist_raw", width = "50%">



```{r include=FALSE, results='hide', message=FALSE, warning=FALSE}
# This code chunk runs in the background and actually imports the dataset while transforming "." to NA.
# The import code chunk above (with eval=FALSE) does not run, but shows the viewer the default import code.
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist", na=".")
```


## Align the dataset with the data dictionary  
When using a non-standardized dataset, the variable names and values must be aligned with the data dictionary. **This process can take some time** and requires looking back-and-forth between your dataset, RStudio, and the MSF data dictionary. In this example, here are the steps taken:  

### Review the MSF data dictionary
Uncomment and run this command, found in the read_nonDHIS_data chunk, to view the MSF data dictionary for the disease ("AJS" in this example).

```{r eval = FALSE}
# Creates object linelist_dict using the msf_dict function from the sitrep package
linelist_dict <- msf_dict("AJS", compact = FALSE) %>%
  select(option_code, option_name, everything())
```

The dataframe linelist_dict should appear in your Environment pane. You can view the data dictionary by running the command `View(linelist_dict)` (note capital V), or by clicking linelist_dict in the Environment pane.  

![](/images/AJS_Data_Dictionary.png)

### Clean the variable names  
These steps standardize how your variable names are written, such as changing spaces and dots to underscores ("_"). **Uncomment these lines of code in the read_nonDHIS_data chunk**.  

**First, make a copy of the dataframe linelist_raw but with a new name: linelist_cleaned.** Throughout the template you will modify and improve this linelist_cleaned dataframe. However, you can always return to the linelist_raw version for reference.  

```{r}
## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw
```

**Second, use the clean_labels() function** from the epitrix package to fix any variable names with non-standard syntax. These code lines take the column names, clean them, and then store the cleaned names in the vector cleaned_colnames. The second code line over-writes the old column names of linelist_cleaned with the improved ones.

```{r}
# Store cleaned column names
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

# Overwrite variable column names with clean ones
colnames(linelist_cleaned) <- cleaned_colnames
```

### Re-name variables to align with data dictionary  

Standardized variable names are required for this template to work smoothly, and the variable names in our Am Timan dataset do not align with the names this template expects. The template offers code that you can uncomment if you only have to change a few variable names (see below). **However, in this example we need to change many variable names. For this scenario, MSF developed a special function to help map our variables to the expected variable names.**  

* **Paste the disease-specific rename helper into the script.** This command is found in the template near the end of the "read_nonDHIS_data"" chunk. For our example we run the command `msf_dict_rename_helper("AJS")` and a block of code text is copied to our clipboard. Return to the template script and *paste* from the clipboard into the template. For the AJS template, the code that is pasted will look like the code below. This code uses the function rename() to change variable names.  

*Note: Be sure to paste the code into an existing R code chunk, not into the white space of the RMarkdown script. 

<img src="/images/Variable_Helper_Paste.gif" alt="rename variables empty snip", width = "100%">

* **Complete the mapping of variable names.** To the right of the equals sign, and before the comma, type the *exact* names of the variables from your dataset that correspond to the expected MSF data dictionary variables on the left. *If there is a data dictionary variable that is not present in your dataset, be sure to comment (#) out that line, as shown in the GIF below.*

![](/images/AJS_Variable_Names.gif)  

**Tip: **If you see this error:  
`Error in is_symbol(expr) : argument "expr" is missing, with no default`  
then you likely forgot to comment (#) the line for a variable you did not use.  

And now you can see the result:  

<img src="/images/AJS_Rename_Variables_Proof.png" alt="rename variables proof", width = "100%">


```{r include=FALSE, results='hide', message=FALSE, warning=FALSE}
## Add the appropriate column names after the equals signs

linelist_cleaned <- rename(linelist_cleaned,
#  event_file_type                   =   , # TEXT                # (Not in dataset)
  case_number                       =   hevid, # TEXT
  date_of_admission                 =   dtmedical, # DATE
  detected_by                       =   referredby, # TEXT
  patient_facility_type             =   hospitalised, # TEXT
#  msf_involvement                   =   , # TEXT                # (Not in dataset)
  age_years                         =   age, # INTEGER_POSITIVE
#  age_months                        =   , # INTEGER_POSITIVE   # (Dataset only has years)
#  age_days                          =   , # INTEGER_POSITIVE   # (Dataset only has years)
  sex                               =   sex, # TEXT
  patient_origin                    =   quartier, # ORG UNIT
#  residential_status_brief          =   , # TEXT               # (Not in dataset)
#  arrival_date_in_area_if_3m        =   , # DATE               # (Not in dataset)
#  ever_received_hepatitis_e_vaccine =   , # TEXT               # (Not in dataset)
#  date_of_last_vaccination          =   , # DATE               # (Not in dataset)
  date_of_onset                     =   dtjaundice, # DATE
#  history_of_fever                  =   , # BOOLEAN            # (Not in dataset)
  fever                             =   medfever, # BOOLEAN
  nausea_anorexia                   =   mednausea, # BOOLEAN
  vomiting                          =   medvomit, # BOOLEAN
  epigastric_pain_heartburn         =   medepigastric, # BOOLEAN
  generalized_itch                  =   meditching, # BOOLEAN
  headache                          =   medheadache, # BOOLEAN
  joint_pains                       =   medarthralgia, # BOOLEAN
  diarrhoea                         =   meddiar, # BOOLEAN
  bleeding                          =   medbleeding, # BOOLEAN
#  convulsions                       =   , # BOOLEAN            # (Not in dataset)
  mental_state                      =   medmental, # BOOLEAN    # !(Needs value cleaning)
  other_symptoms                    =   medother, # BOOLEAN
  other_cases_in_hh                 =   medothhhajs, # BOOLEAN
#  traditional_medicines             =   , # BOOLEAN            # (Not in dataset)
#  traditional_medicine_details      =   , # TEXT               # (Not in dataset)
#  recent_travel                     =   , # BOOLEAN            # (Not in dataset)
#  water_source                      =   , # TEXT               # !(Split across many variables)
  malaria_rdt_at_admission          =   medmalrdt, # TEXT
  hep_b_rdt                         =   medhepb, # TEXT
  hep_c_rdt                         =   medhepc, # TEXT
  hep_e_rdt                         =   medhevrdt, # TEXT
#  dengue_rdt                        =   , # TEXT               # (Not in dataset)
  date_lab_sample_taken             =   medblooddt, # DATE
  test_hepatitis_a                  =   medhavelisa, # TEXT
  test_hepatitis_b                  =   medhbvelisa, # TEXT
  test_hepatitis_c                  =   medhcvelisa, # TEXT
  test_hepatitis_e_virus            =   medhevelisa, # TEXT
  test_hepatitis_e_igm              =   hevrecent, # TEXT
#  test_hepatitis_e_igg              =   , # TEXT               # (In same variable as elisa result)
  test_hepatitis_e_genotype         =   hevgenotype, # TEXT
#  malaria_blood_film                =   , # TEXT               # (Not in dataset)
  dengue                            =   dengue, # TEXT
  yellow_fever                      =   yf, # TEXT
#  lassa_fever                       =   , # TEXT               # (Not in dataset)
#  typhoid                           =   , # TEXT               # (Not in dataset)
  chikungunya_onyongnyong           =   chik, # TEXT
#  ebola_marburg                     =   , # TEXT               # (Not in dataset)
  other_arthropod_transmitted_virus =   arbovpcr, # TEXT
#  other_pathogen                    =   , # TEXT               # (Not in dataset)
#  lab_comments                      =   , # TEXT               # (Not in dataset)
  pregnant                          =   medpreg, # TEXT
  trimester                         =   medpregtri, # TEXT
#  foetus_alive_at_admission         =   , # TEXT               # (Not in dataset)
#  delivery_event                    =   , # TRUE_ONLY          # (Not in dataset)
  pregnancy_outcome_at_exit         =   medppoutcome, # TEXT
  exit_status                       =   outcomehp, # TEXT
#  date_of_exit                      =   , # DATE               # (Not in dataset)
#  time_to_death                     =   , # TEXT               # (Not in dataset)
  treatment_facility_site           =   hpid, # TEXT
#  treatment_location                =   , # ORGANISATION_UNIT  # (Not in dataset)
  patient_origin_free_text          =   block # TEXT
)
```





## Provide population counts  
The population estimates for regions and age groups are collected in order to calculate attack and mortality rates. **The template allows several ways to provide population estimates, but importantly, the data must be stored under specific variable names.** In your real-use case, the specific age groupings and region names in your data may differ from the examples, but the variable names must follow the expected standard.  

You can do one of the following:  
1) Enter the estimates directly **[need clarification here as this is not yet built]**  
2) Use the function gen_population() to derive the estimates from proportions  
3) Import a spreadsheet file with the estimates in the correct format  

![](/images/AJS_Population_Counts.png)  

For the AJS example, we can use an Excel spreadsheet containing population figures by region. Uncomment this line of code in the read_population_data chunk and modify it to import the Excel spreadsheet (link for spreadsheet download at top of this webpage). Note that the spreadsheet variables names have already been edited to match the expected names ("patient_origin" and "population").  

As they will not be used, delete or comment (#) all the code lines in the chunk that create fake data for population_data_region, population_data_age, and population_data_age_months.

>The file path you provide to the function may differ. A few notes about file paths:  
* If copying a file path from Microsoft computer, you will need to reverse any slashes from \ to /.  
* [NOTES ON USING HERE and RIO::IMPORT]  

```{r}
population_data_region <- rio::import("AJS_AmTiman_population_revised_for_template.xlsx", which="quartier")
```


**If you choose not to complete the population estimates section, delete the default gen_population() code, and expect that later sections on attack and mortality rates will not produce output.**






## Lab data
**TODO: [Paragraph about lab data here - how it is used]**  






## Browse data  
This code chunk can be used to explore your data, but remember to eventually comment these code lines if you do not want these outputs in your final report.




## Standardize and clean data  
Becuase the Am Timan dataset is not yet aligned with the MSF data dictionary and what the template expects, there are several data cleaning steps we must complete.  

### Re-code missing values from periods (.) to `NA` at import  

Currently, missing values in the dataset are represented by a period (.). This causes problems because R expects missing values to be coded as `NA`. For example, if we attempt to set the variable date_of_onset to class Date, R gives an error because the periods are considered character values that do not fit the expected YYYY-MM-DD date format.  

To fix this problem we **scroll up to the read_nonDHIS_data chunk of the template and insert an additional argument in the rio::import command**. The argument `na = "."` specifies a period as the value in the Excel sheet that R will consider to be "missing". As the data are re-imported, all cells with that value are now changed to `NA`.  

**Remember that after making this change to the import command you must re-run the entire script. This way, the dataset is correctly imported AND the later cleaning steps, changes to variable names, etc. are also performed on this newly-imported dataset** 

```{r eval=FALSE}
# The old import command
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist")

# The revised import command (don't forget the comma between arguments!)
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist", na = ".")
```

### Drop ineligible observations  
The next code item in the script drops observations with missing case_number or date_of_consultation_admission. Because the Am Timan dataset contains observations for patients seen in the community and at the hospital, these criteria may not be relevant. We can check and see that of the 1447 observations, there are 0 missing case_number or dateentry, but 616 observations missing date_of_admission. These 616 community-identified cases are still of interest for our report, so we will not drop them. 

```{r eval=FALSE}
# Find the number of observations missing date_of_admission
nrow(linelist_cleaned %>% filter(is.na(date_of_admission))) 
```

### Convert and clean date variables
In linelist_cleaned there are seven variables containing dates (dateentry, epiquestdate, date_of_admission, date_of_onset, date_lab_sample_taken, dthospitalisation, dtdeath).  

Because the Am Timan dataset contains date variables not found in the data dictionary, we will ignore and comment out the first code of the Date variables chunk (these commands convert only the date variables known to the data dictionary).  

Instead, we uncomment and **use the commands applicable to when a dataset does not align with the data dictionary**. You may see messages warning that a few dates are not in the correct timeframe - this is ok and these dates will be addressed in the next step.

```{r results='hide', message=FALSE, warning=FALSE}
# Use this is your dataset aligns with the data dictionary
# Creates list of date variables from the data dictionary
#DATEVARS <- filter(linelist_dict, data_element_valuetype == "DATE") %>% 
#  select(data_element_shortname) # select date vars
# change to the date variables found in your dataset to class date 
#linelist_cleaned <- linelist_cleaned %>%
#  mutate_at(DATEVARS$data_element_shortname, as.Date)

# Use this if your dataset does not align with the data dictionary
  linelist_cleaned <- linelist_cleaned %>%
    mutate_at(vars(matches("date|Date")), linelist::guess_dates,
            error_tolerance = 0.5)
```

The code above converted successfully many of our date variables (remember you can check class like `class(linelist$date_of_onset`). However, did not detect the variables named with "dt", such as "dtdeath" and "dthospitalization". We must **convert those variables manually**:  

```{r}
# Individually convert other date columns
class(linelist_cleaned$dtdeath)

linelist_cleaned$dtdeath <- linelist::guess_dates(linelist_cleaned$dtdeath)

class(linelist_cleaned$dtdeath)

# Repeat for variable "dtdeath"
linelist_cleaned$dthospitalisation <- linelist::guess_dates(linelist_cleaned$dthospitalisation)
```

Next we uncomment code to **correct unrealistic dates**. We have browsed our data and know that there are observations with date_of_onset outside the reasonable range:
```{r}
# Check range of date_of_onset values, ignoring (removing) missing values
range(linelist_cleaned$date_of_onset, na.rm = TRUE)
```

We convert dates outside the expected range (April 2016 to October 2017) to missing using case_when(). Note that when making the assignment on the right-hand side (RHS), wrap NA in as.Date().  

As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that **each left-hand side (LHS) of the ~ must be a logical statement**, not just a value. Best is to write case_when() lines from most specific at top to most general at bottom. You can read more about case_when() [here](https://dplyr.tidyverse.org/reference/case_when.html).  

**Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write `NA` on the RHS. Instead you must use the special character version of `NA` : `NA_character_`.** 

```{r}
# Convert dates before April 2016 or after October 2017 to missing (NA)
linelist_cleaned <- mutate(linelist_cleaned,
                           date_of_onset = case_when(
                                 date_of_onset < as.Date("2016-04-01")  ~ as.Date(NA),
                                 date_of_onset > as.Date("2017-10-31")  ~ as.Date(NA),
                                 TRUE                                   ~ date_of_onset
                                 ))
                           
```

We also must **use the provided code to create a variable called "epiweek"**. While there are already variables in our dataset that give the epidemiological weeks of various data points, it is safer to make a new variable AND later code chunks rely on the variable being named "epiweek". See the documentation of the [package "aweek"](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html) for more information.

```{r}
# Create variable epiweek
linelist_cleaned$epiweek <- aweek::date2week(linelist_cleaned$date_of_onset, 
                                             floor_day = TRUE, 
                                             factor = TRUE)
```

### Clean numeric variables  

We can **comment out/ignore the code that makes a new numeric variable "obs_days"**, because we do not have a date_of_exit in our dataset.  

**However, we do need to clean the variable "age_years"**. If we look at the range of values, we get something strange:  
```{r}
# See the range of age_years values, removing (excluding) NA
range(linelist_cleaned$age_years, na.rm = TRUE)
```
We know there are ages older than 9 years. We check `class(linelist_cleaned$age_years)` and see that R is reading this variable as class *character*, not numeric! So we must convert it by adding the following command to the script:
```{r}
# Convert variable age_years to numeric class
linelist_cleaned$age_years <- as.numeric(linelist_cleaned$age_years)
```

**Now we must further clean the age-related variables.** In the chunk "Age group variables", we do not need and can comment out the code to add under 2 years to the age_years variable. However, we do have some decimal years. To align with the data dictionary we uncomment and **use the code to create a *new* variable "age_months" from the decimal years**.  

```{r}
# For patients under 5 years, the new variable age_months is based on age_years * 12 
linelist_cleaned <- mutate(linelist_cleaned,
                            age_months = case_when(
                              age_years < 5 ~ age_years * 12
                              )) 
```

We can then use the code to create an age group variable based on age_months.  

```{r}
## create age group variable for under 5 years based on months
linelist_cleaned$age_group_mon <- age_categories(linelist_cleaned$age_months, 
                                                 breakers = c(0, 6, 9, 12, 24), 
                                                 ceiling = TRUE)
```

...and use the similar code for groups of age_years. A note on grouping using age_categories(): for example with breakers 0, 3, 15, 30, and 45, a 30-year old patient will be included in an age_group named "30-44".

```{r}
## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 3, 15, 30, 45))
```

### Cleaning categorical variables  
While the template directs us to next create a DIED variable based on exit_status containing the characters "Dead", we must first **clean our exit_status variable, which is currrently in French**. 

**Use case_when() to assign new values for a new exit_status2 variable**, as in the code below. The code uses the function case_when() to re-define linelist_cleaned as itself, but mutated to include the new variable exit_status2. The values in exit_status2 are based on the values in exit_status, such that when exist_status == "Décédé", the value in exit_status2 is "Died", and so on. 

As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that **each left-hand side (LHS) of the ~ must be a logical statement**, not just a value. Best is to write case_when() lines from most specific at top to most general at bottom. You can read more about case_when() [here](https://dplyr.tidyverse.org/reference/case_when.html).  

**Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write `NA` on the RHS. Instead you must use the special character version of `NA` : `NA_character_`.** 

```{r}
# Tabulate to see all possible values of exit_status
table(linelist_cleaned$exit_status, useNA = "always")

# Create exit_status2 from values in exit_status
linelist_cleaned <- linelist_cleaned %>% 
  mutate(exit_status2 = case_when(
    exit_status == "Décédé"          ~ "Died",
    exit_status == "-"               ~ NA_character_,
    exit_status == "Echappé"         ~ "Left",
    exit_status == "Déchargé/Guéri"  ~ "Discharged"
  ))

# Tabulate the NEW exit_status2 variable to check correct assignment
table(linelist_cleaned$exit_status2, useNA = "always")
```


Now we can **make the DIED variable**, which is referenced in later code chunks. This command creates DIED as a logical (TRUE/FALSE) variable), depending on whether each observation meets the criteria to the right of the assignment operator `<-`.

```{r}
## Note we are directing R to look within the NEW exit_status2 variable
linelist_cleaned$DIED <- linelist_cleaned$exit_status2 == "Died"
```


### **Re-code values in patient_facility_type**  

When we assigned our variables to match the data dictionary, we used the variable "hospitalisation" as the variable "patient_facility_type". **However, the values in that variable do not match those expected by the template.** In the data dictionary, patient_facility_type should have values of "Inpatient" or "Outpatient." Currently, the values are "Oui" and "Non". In later code chunks, analyses are restricted to observations where patient_facility_type == "Inpatient", thus, we should align the values to match the data dictionary.  

**To clean these values we uncomment and modify code from the standardise_clean_data chunk, found under the heading "recode a character variable".** 

```{r}
# View all the values in patient_facility_type
table(linelist_cleaned$patient_facility_type, useNA = "always")

# Convert the values
linelist_cleaned <- linelist_cleaned %>% 
  mutate(patient_facility_type = case_when(
    patient_facility_type == "Oui" ~ "Inpatient",
    patient_facility_type == "Non" ~ "Outpatient"
  ))

# Re-check that the values converted sucessfully
table(linelist_cleaned$patient_facility_type, useNA = "always")

```

We can **comment/ignore the code to change the order of levels in categorical variables**, as the Am Timan dataset does not include a variable time_to_death and we do not need to change the order of any categorical variables.  

**However, we do need to create a case definition variable.** In this use of case_when(), the last line left-hand side (LHS) is TRUE, which serves as a catch-all for any other possible values that have not yet met the criteria of the earlier case_when lines.

```{r}
# You MUST modify this section to match your case definition. The below
# uses positive RDT for Confirmed and epi link only for Probable.
#
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == "Positive"                               ~ "Confirmed",
    hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
    TRUE                                                  ~ "Suspected"
  ))
```

### Create lists of variables  

These variables names are stored in vectors that are created using the function c(). These vectors of names will be referenced in later code chunks. This code creates two vectors - one for symptoms variables and one for laboratory testing variables.  

**Some of these variables do not apply to our Am Timan data and must be removed from the list or commented out (such as convulsions and history of fever).** If non-existant variables are left in the list it will cause errors in later code chunks.

```{r}
# vectors of variable names ----------------------------------------------------

## You may want to group the names of several variables that have the same possible 
## values in to a named vector. 
## This way if you want to run the same function over these variables you can 
## simply use the named vector rather than typing out each variable individually

# create a grouping of all symptoms 
SYMPTOMS <- c("generalized_itch", 
#             "history_of_fever", 
              "fever",
              "joint_pains",
              "epigastric_pain_heartburn",
              "nausea_anorexia",
              "vomiting", 
              "diarrhoea",
              "bleeding", 
              "headache",
              "mental_state",
#              "convulsions",
              "other_symptoms"  
              )

# create a grouping of all lab tests 
LABS <- c("hep_b_rdt", 
          "hep_c_rdt",
          "hep_e_rdt",
          "test_hepatitis_a",
          "test_hepatitis_b",
          "test_hepatitis_c",
#          "test_hepatitis_e_igg",
          "test_hepatitis_e_igm" ,
          "test_hepatitis_e_genotype",
          "test_hepatitis_e_virus",
          "malaria_rdt_at_admission",
#          "malaria_blood_film", 
          "dengue",
#          "dengue_rdt", 
          "yellow_fever",
#          "typhoid",
          "chikungunya_onyongnyong", 
#          "ebola_marburg",
#          "lassa_fever",
          "other_arthropod_transmitted_virus" 
#          "other_pathogen"
          )

```

### Dropping observations  

The next code assists with **dropping observations and variables**. We can remove any observations with date of onset after the reporting_week (reporting_week is defined at the beginning of the script).  

**Note: The default code in the template also removes observations with missing (NA) date_of_onset. We can add ` | is.na(date_of_onset)` into the filter to keep these.** 

```{r}
# Drop cases after reporting week
linelist_cleaned <- linelist_cleaned %>% 
  filter(date_of_onset <= week2date(sprintf("%s-7", reporting_week)) | is.na(date_of_onset))
```

Then, it is important to **define these date-related objects** that are referenced in later code chunks.  

```{r}
# define the first week of outbreak (date of first case)
first_week <- levels(linelist_cleaned$epiweek)[1]

# outbreak start 
# return the first day in the week of first case 
obs_start <- week2date(sprintf("%s-1", first_week))

# return last day of reporting week 
obs_end   <- week2date(sprintf("%s-7", reporting_week))

```

### Export if desired  

And finally, if desired you can **export the cleaned dataset** for other purposes.

```{r save_cleaned_data, eval = FALSE}
## OPTIONAL: save your cleaned dataset! 
## put the current date in the name so you know!
rio::export(linelist_cleaned, paste0("AmTiman_linelist_cleaned_", Sys.Date(), ".xlsx"))
```

```{r, include=FALSE, results='hide', message=FALSE, warning=FALSE}
saveRDS(linelist_cleaned, "data/linelist_cleaned.rds")
```

