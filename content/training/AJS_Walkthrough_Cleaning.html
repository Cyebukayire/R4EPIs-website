---
date: "2019-08-05T14:07:44+02:00"
title: Template Walk-through - Data Import and Cleaning
weight: 8
---



<div id="overview-of-this-page" class="section level2">
<h2>Overview of this page</h2>
<p>This page will demonstrate use of the Acute Jaundice Syndrome (AJS) outbreak template using data from an outbreak in Am Timan, Chad. This first page covers the initial data importation and cleaning steps in the template.</p>
<div id="getting-started" class="section level4">
<h4>Getting started</h4>
<p><strong>Getting started with the sitrep package and opening the correct template</strong> Please review the <a href="https://r4epis.netlify.com/welcome/001-getting-started/">getting started page</a> for instructions on the following start-up steps:</p>
<ul>
<li>Downloading and configuring R and RStudio<br />
</li>
<li>Installing the sitrep package<br />
</li>
<li>Opening an outbreak or survey template</li>
</ul>
<p><strong>Access the datasets for this walk-through</strong><br />
[TODO: instructions and link to dataset here]</p>
<p><strong>Access the final RMarkdown script used in this walk-through</strong><br />
[TODO: link to download Chad AJS RMarkdown here]</p>
<p><strong>RMarkdown resources</strong><br />
Review the page “Reading a RMarkdown Script”, or reference these resources: <a href="https://rmarkdown.rstudio.com/articles_intro.html">Rmarkdown introduction</a> and <a href="https://rmarkdown.rstudio.com/authoring_basics.html">Rmarkdown authoring basics</a>.</p>
</div>
<div id="ajshev-outbreak-in-am-timan-chad-2016-2017" class="section level4">
<h4>AJS/HEV outbreak in Am Timan, Chad (2016-2017)</h4>
<p>We will be using data and examples from a real outbreak of Hepatitis E virus (HEV) infection which occurred in the Chadian town of Am Timan between October 2016 and April 2017</p>
<p><em>DISCLAIMER: The real data from the outbreak has been used for the training materials linked to the outbreak templates of the R4epis project. The Chadian Ministry of Health (MoH) has approved the use of this data for training purposes. Please note, that some data has been adapted in order to best achieve training objectives. Also, the GPS coordinates included in the dataset do not correspond to real cases identified during this outbreak. They have been generated exclusively for training purposes.</em></p>
<p>In early September 2016, a cluster of severely ill pregnant women with jaundice was detected at the Am Timan Hospital in the maternity ward. Following rapid tests conducted in Am Timan and confirmatory testing in the Netherlands, this was confirmed as due to HEV infection. Thus the MoH and MSF outbreak response was activated.</p>
<p>The response consisted of four components:</p>
<ol style="list-style-type: decimal">
<li>active community based surveillance (CBS)<br />
</li>
<li>clinical assessment and management of ill cases at the hospital<br />
</li>
<li>water chlorination activities at most water points in the town<br />
</li>
<li>hygiene promotion</li>
</ol>
<p><strong>The outbreak linelist data was combined data from the active CBS data and the clinical data from the hospital.</strong> The CBS functioned with community health workers visiting all households in the town every two weeks and actively searching for people with Acute Jaundice Syndrome (AJS). For this group of persons (suspected cases), only those that were visibly ill or that were pregnant were referred to the hospital for clinical assessment and admission if required. Persons that self-reported to the hospital or that arrived after referral would undergo a clinical assessment and a rapid test for HEV for diagnosis. Thus only for people assessed at the hospital were we able to capture a confirmed case status.</p>
<p>For the duration of the outbreak we detected 1193 suspected cases, 100 confirmed cases and discarded 150 cases with AJS who were not positive for HEV infection.</p>
<p><a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0188240">Link to publication</a></p>
<p><img src="/images/AJS_Article.png" alt="AJS Article snip", width = "40%"></p>
</div>
</div>
<div id="overview-of-template" class="section level2">
<h2>Overview of template</h2>
<p><strong>TODO: Graphic showing big-picture overview of template parts</strong></p>
</div>
<div id="header-and-introduction" class="section level2">
<h2>Header and introduction</h2>
<p>The very top of the template consists of a header surrounded by <code>---</code> lines. Here you may want to edit the title of your document. The other settings in the header define the default document type produced (Microsoft Word) when the RMarkdown is “knit”.</p>
<p>The “Introduction to this template” section is for your information only and this text can be deleted before knitting the document.</p>
<p><img src="/images/AJS_Intro.png" alt="AJS Header and Introduction snip", width = "75%"></p>
</div>
<div id="installation-and-loading-packages" class="section level2">
<h2>Installation and loading packages</h2>
<p><strong>The text which explains the purpose of this code chunk may be deleted, but you must keep the code chunk!</strong> The code will run without producing any output in your final report, but it is required to install (or load using library(), if already installed) the packages necessary to produce the report.</p>
<p>This “setup” code chunk does the following:</p>
<ul>
<li><p>Set default settings for tables such as size, error handling, and display of missing values</p></li>
<li><p>Create a vector of names of packages required for the template to run, each of which is installed if it is not already installed, and then is loaded using library() for use in the current R session.</p></li>
<li><p>Set default text size in graphic plots</p></li>
<li><p>Set epidemiological weeks to begin on Mondays</p></li>
</ul>
<p><img src="/images/Package_Installation.png" alt="Package installation chunk snip", width = "75%"></p>
<div id="about-the-packages-used-in-this-template" class="section level3">
<h3>About the packages used in this template</h3>
<div id="generic-packages" class="section level4">
<h4>Generic packages</h4>
<ul>
<li>knitr used to create the output document (pdf, doc, html)<br />
</li>
<li>dplyr used to clean and shape the data<br />
</li>
<li>epitrix used for data cleaning and variable standardisation<br />
</li>
<li>ggplot2 used to visualise your data using different plotting methods</li>
</ul>
</div>
<div id="more-epidemiology-specific-packages" class="section level4">
<h4>More epidemiology-specific packages</h4>
<ul>
<li>sitrep includes a variety of useful field epidemiology functions<br />
</li>
<li>incidence used for creating epicurves<br />
</li>
<li>ISOweek used for creating epiweeks<br />
</li>
<li>epitools used for creating 2by2 tables</li>
</ul>
</div>
<div id="mapping-packages" class="section level4">
<h4>Mapping packages</h4>
<ul>
<li>ggspatial used for selecting basemap tiles<br />
</li>
<li>sf used for manipulating spatial objects (e.g. polygons) easily</li>
</ul>
</div>
</div>
</div>
<div id="set-current-epi-week" class="section level2">
<h2>Set current epi week</h2>
<p>Set the epidemiological week for the report. <strong>This value is used in later code chunks, for example when producing epidemic curves.</strong> Note that you may want to specify the most recent <strong>complete</strong> epi week. Follow the format in the code below (within quotes give the 4-digit year, a hyphen (-), capital W, then the 2-digit epi week number).</p>
<p>By default in the templates epi weeks begin on Mondays (this can be changed at the bottom of the “setup” code chunk). See the documentation of the <a href="https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html">package “aweek”</a> for more information.</p>
<pre class="r"><code>reporting_week &lt;- &quot;2017-W52&quot;  # Set the reporting week</code></pre>
<p>To determine which epi week it is currently (based on the template epi week settings), use the code below:</p>
<pre class="r"><code>date2week(Sys.Date())      #Sys.Date() uses the current date from your computer</code></pre>
<pre><code>## &lt;aweek start: Monday&gt;
## [1] &quot;2019-W34-1&quot;</code></pre>
</div>
<div id="import-the-dataset" class="section level2">
<h2>Import the dataset</h2>
<p><strong>In this template section you choose the appropriate code chunk to importing your dataset.</strong></p>
<p><img src="/images/AJS_Data_Import.png" alt="Data import options snip", width = "75%"></p>
<p>For this exercise our dataset is a <strong>non-standardized Excel file</strong> from MSF’s response an outbreak of AJS in Am Timan, Chad, so we use the <code>read_nonDHIS_data</code> code chunk. We will specifically use the line that uses the import() function of the rio package to import an Excel file that is not password protected. Note that errors can occur if you provide an incorrect file name or path. Tlink for dataset download is at the top of this webpage.</p>
<p>Either <strong>delete or comment out (#)</strong> all lines of code in the other data import chunks (read_fake_data, read_DHIS_excel_data, and read_DHIS_csv_data).</p>
<pre class="r"><code>## Read data ------------------------------------
# Excel file
# to read in a specific sheet use &quot;which&quot;
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;)</code></pre>
<p>There should now be a dataframe object named “linelist_raw” in your environment pane, consisting of 1447 observations and 122 variables.</p>
<p><img src="/images/linelist_raw_imported.png" alt="Environment snip with linelist_raw", width = "50%"></p>
</div>
<div id="align-the-dataset-with-the-data-dictionary" class="section level2">
<h2>Align the dataset with the data dictionary</h2>
<p>When using a non-standardized dataset, the variable names and values must be aligned with the data dictionary. <strong>This process can take some time</strong> and requires looking back-and-forth between your dataset, RStudio, and the MSF data dictionary. In this example, here are the steps taken:</p>
<div id="review-the-msf-data-dictionary" class="section level3">
<h3>Review the MSF data dictionary</h3>
<p>Uncomment and run this command, found in the read_nonDHIS_data chunk, to view the MSF data dictionary for the disease (“AJS” in this example).</p>
<pre class="r"><code># Creates object linelist_dict using the msf_dict function from the sitrep package
linelist_dict &lt;- msf_dict(&quot;AJS&quot;, compact = FALSE) %&gt;%
  select(option_code, option_name, everything())</code></pre>
<p>The dataframe linelist_dict should appear in your Environment pane. You can view the data dictionary by running the command <code>View(linelist_dict)</code> (note capital V), or by clicking linelist_dict in the Environment pane.</p>
<div class="figure">
<img src="/images/AJS_Data_Dictionary.png" />

</div>
</div>
<div id="clean-the-variable-names" class="section level3">
<h3>Clean the variable names</h3>
<p>These steps standardize how your variable names are written, such as changing spaces and dots to underscores (“_“). <strong>Uncomment these lines of code in the read_nonDHIS_data chunk</strong>.</p>
<p><strong>First, make a copy of the dataframe linelist_raw but with a new name: linelist_cleaned.</strong> Throughout the template you will modify and improve this linelist_cleaned dataframe. However, you can always return to the linelist_raw version for reference.</p>
<pre class="r"><code>## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned &lt;- linelist_raw</code></pre>
<p><strong>Second, use the clean_labels() function</strong> from the epitrix package to fix any variable names with non-standard syntax. These code lines take the column names, clean them, and then store the cleaned names in the vector cleaned_colnames. The second code line over-writes the old column names of linelist_cleaned with the improved ones.</p>
<pre class="r"><code># Store cleaned column names
cleaned_colnames &lt;- epitrix::clean_labels(colnames(linelist_raw))

# Overwrite variable column names with clean ones
colnames(linelist_cleaned) &lt;- cleaned_colnames</code></pre>
</div>
<div id="re-name-variables-to-align-with-data-dictionary" class="section level3">
<h3>Re-name variables to align with data dictionary</h3>
<p>Standardized variable names are required for this template to work smoothly, and the variable names in our Am Timan dataset do not align with the names this template expects. The template offers code that you can uncomment if you only have to change a few variable names (see below). <strong>However, in this example we need to change many variable names. For this scenario, MSF developed a special function to help map our variables to the expected variable names.</strong></p>
<ul>
<li><strong>Paste the disease-specific rename helper into the script.</strong> This command is found in the template near the end of the “read_nonDHIS_data”&quot; chunk. For our example we run the command <code>msf_dict_rename_helper(&quot;AJS&quot;)</code> and a block of code text is copied to our clipboard. Return to the template script and <em>paste</em> from the clipboard into the template. For the AJS template, the code that is pasted will look like the code below. This code uses the function rename() to change variable names.</li>
</ul>
<p>*Note: Be sure to paste the code into an existing R code chunk, not into the white space of the RMarkdown script.</p>
<p><img src="/images/Variable_Helper_Paste.gif" alt="rename variables empty snip", width = "100%"></p>
<ul>
<li><strong>Complete the mapping of variable names.</strong> To the right of the equals sign, and before the comma, type the <em>exact</em> names of the variables from your dataset that correspond to the expected MSF data dictionary variables on the left. <em>If there is a data dictionary variable that is not present in your dataset, be sure to comment (#) out that line, as shown in the GIF below.</em></li>
</ul>
<div class="figure">
<img src="/images/AJS_Variable_Names.gif" />

</div>
<p><strong>Tip: </strong>If you see this error:<br />
<code>Error in is_symbol(expr) : argument &quot;expr&quot; is missing, with no default</code><br />
then you likely forgot to comment (#) the line for a variable you did not use.</p>
<p>And now you can see the result:</p>
<p><img src="/images/AJS_Rename_Variables_Proof.png" alt="rename variables proof", width = "100%"></p>
</div>
</div>
<div id="provide-population-counts" class="section level2">
<h2>Provide population counts</h2>
<p>The population estimates for regions and age groups are collected in order to calculate attack and mortality rates. <strong>The template allows several ways to provide population estimates, but importantly, the data must be stored under specific variable names.</strong> In your real-use case, the specific age groupings and region names in your data may differ from the examples, but the variable names must follow the expected standard.</p>
<p>You can do one of the following:<br />
1) Enter the estimates directly <strong>[need clarification here as this is not yet built]</strong><br />
2) Use the function gen_population() to derive the estimates from proportions<br />
3) Import a spreadsheet file with the estimates in the correct format</p>
<div class="figure">
<img src="/images/AJS_Population_Counts.png" />

</div>
<p>For the AJS example, we can use an Excel spreadsheet containing population figures by region. Uncomment this line of code in the read_population_data chunk and modify it to import the Excel spreadsheet (link for spreadsheet download at top of this webpage). Note that the spreadsheet variables names have already been edited to match the expected names (“patient_origin” and “population”).</p>
<p>As they will not be used, delete or comment (#) all the code lines in the chunk that create fake data for population_data_region, population_data_age, and population_data_age_months.</p>
<blockquote>
<p>The file path you provide to the function may differ. A few notes about file paths:<br />
* If copying a file path from Microsoft computer, you will need to reverse any slashes from  to /.<br />
* [NOTES ON USING HERE and RIO::IMPORT]</p>
</blockquote>
<pre class="r"><code>population_data_region &lt;- rio::import(&quot;AJS_AmTiman_population_revised_for_template.xlsx&quot;, which=&quot;quartier&quot;)</code></pre>
<p><strong>If you choose not to complete the population estimates section, delete the default gen_population() code, and expect that later sections on attack and mortality rates will not produce output.</strong></p>
</div>
<div id="lab-data" class="section level2">
<h2>Lab data</h2>
<p><strong>TODO: [Paragraph about lab data here - how it is used]</strong></p>
</div>
<div id="browse-data" class="section level2">
<h2>Browse data</h2>
<p>This code chunk can be used to explore your data, but remember to eventually comment these code lines if you do not want these outputs in your final report.</p>
</div>
<div id="standardize-and-clean-data" class="section level2">
<h2>Standardize and clean data</h2>
<p>Becuase the Am Timan dataset is not yet aligned with the MSF data dictionary and what the template expects, there are several data cleaning steps we must complete.</p>
<div id="re-code-missing-values-from-periods-.-to-na-at-import" class="section level3">
<h3>Re-code missing values from periods (.) to <code>NA</code> at import</h3>
<p>Currently, missing values in the dataset are represented by a period (.). This causes problems because R expects missing values to be coded as <code>NA</code>. For example, if we attempt to set the variable date_of_onset to class Date, R gives an error because the periods are considered character values that do not fit the expected YYYY-MM-DD date format.</p>
<p>To fix this problem we <strong>scroll up to the read_nonDHIS_data chunk of the template and insert an additional argument in the rio::import command</strong>. The argument <code>na = &quot;.&quot;</code> specifies a period as the value in the Excel sheet that R will consider to be “missing”. As the data are re-imported, all cells with that value are now changed to <code>NA</code>.</p>
<p><strong>Remember that after making this change to the import command you must re-run the entire script. This way, the dataset is correctly imported AND the later cleaning steps, changes to variable names, etc. are also performed on this newly-imported dataset</strong></p>
<pre class="r"><code># The old import command
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;)

# The revised import command (don&#39;t forget the comma between arguments!)
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;, na = &quot;.&quot;)</code></pre>
</div>
<div id="drop-ineligible-observations" class="section level3">
<h3>Drop ineligible observations</h3>
<p>The next code item in the script drops observations with missing case_number or date_of_consultation_admission. Because the Am Timan dataset contains observations for patients seen in the community and at the hospital, these criteria may not be relevant. We can check and see that of the 1447 observations, there are 0 missing case_number or dateentry, but 616 observations missing date_of_admission. These 616 community-identified cases are still of interest for our report, so we will not drop them.</p>
<pre class="r"><code># Find the number of observations missing date_of_admission
nrow(linelist_cleaned %&gt;% filter(is.na(date_of_admission))) </code></pre>
</div>
<div id="convert-and-clean-date-variables" class="section level3">
<h3>Convert and clean date variables</h3>
<p>In linelist_cleaned there are seven variables containing dates (dateentry, epiquestdate, date_of_admission, date_of_onset, date_lab_sample_taken, dthospitalisation, dtdeath).</p>
<p>Because the Am Timan dataset contains date variables not found in the data dictionary, we will ignore and comment out the first code of the Date variables chunk (these commands convert only the date variables known to the data dictionary).</p>
<p>Instead, we uncomment and <strong>use the commands applicable to when a dataset does not align with the data dictionary</strong>. You may see messages warning that a few dates are not in the correct timeframe - this is ok and these dates will be addressed in the next step.</p>
<pre class="r"><code># Use this is your dataset aligns with the data dictionary
# Creates list of date variables from the data dictionary
#DATEVARS &lt;- filter(linelist_dict, data_element_valuetype == &quot;DATE&quot;) %&gt;% 
#  select(data_element_shortname) # select date vars
# change to the date variables found in your dataset to class date 
#linelist_cleaned &lt;- linelist_cleaned %&gt;%
#  mutate_at(DATEVARS$data_element_shortname, as.Date)

# Use this if your dataset does not align with the data dictionary
  linelist_cleaned &lt;- linelist_cleaned %&gt;%
    mutate_at(vars(matches(&quot;date|Date&quot;)), linelist::guess_dates,
            error_tolerance = 0.5)</code></pre>
<p>The code above converted successfully many of our date variables (remember you can check class like <code>class(linelist$date_of_onset</code>). However, did not detect the variables named with “dt”, such as “dtdeath” and “dthospitalization”. We must <strong>convert those variables manually</strong>:</p>
<pre class="r"><code># Individually convert other date columns
class(linelist_cleaned$dtdeath)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>linelist_cleaned$dtdeath &lt;- linelist::guess_dates(linelist_cleaned$dtdeath)

class(linelist_cleaned$dtdeath)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<pre class="r"><code># Repeat for variable &quot;dtdeath&quot;
linelist_cleaned$dthospitalisation &lt;- linelist::guess_dates(linelist_cleaned$dthospitalisation)</code></pre>
<p>Next we uncomment code to <strong>correct unrealistic dates</strong>. We have browsed our data and know that there are observations with date_of_onset outside the reasonable range:</p>
<pre class="r"><code># Check range of date_of_onset values, ignoring (removing) missing values
range(linelist_cleaned$date_of_onset, na.rm = TRUE)</code></pre>
<pre><code>## [1] &quot;2014-11-01&quot; &quot;2017-12-27&quot;</code></pre>
<p>We convert dates outside the expected range (April 2016 to October 2017) to missing using case_when(). Note that when making the assignment on the right-hand side (RHS), wrap NA in as.Date().</p>
<p>As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that <strong>each left-hand side (LHS) of the ~ must be a logical statement</strong>, not just a value. Best is to write case_when() lines from most specific at top to most general at bottom. You can read more about case_when() <a href="https://dplyr.tidyverse.org/reference/case_when.html">here</a>.</p>
<p><strong>Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write <code>NA</code> on the RHS. Instead you must use the special character version of <code>NA</code> : <code>NA_character_</code>.</strong></p>
<pre class="r"><code># Convert dates before April 2016 or after October 2017 to missing (NA)
linelist_cleaned &lt;- mutate(linelist_cleaned,
                           date_of_onset = case_when(
                                 date_of_onset &lt; as.Date(&quot;2016-04-01&quot;)  ~ as.Date(NA),
                                 date_of_onset &gt; as.Date(&quot;2017-10-31&quot;)  ~ as.Date(NA),
                                 TRUE                                   ~ date_of_onset
                                 ))</code></pre>
<p>We also must <strong>use the provided code to create a variable called “epiweek”</strong>. While there are already variables in our dataset that give the epidemiological weeks of various data points, it is safer to make a new variable AND later code chunks rely on the variable being named “epiweek”. See the documentation of the <a href="https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html">package “aweek”</a> for more information.</p>
<pre class="r"><code># Create variable epiweek
linelist_cleaned$epiweek &lt;- aweek::date2week(linelist_cleaned$date_of_onset, 
                                             floor_day = TRUE, 
                                             factor = TRUE)</code></pre>
</div>
<div id="clean-numeric-variables" class="section level3">
<h3>Clean numeric variables</h3>
<p>We can <strong>comment out/ignore the code that makes a new numeric variable “obs_days”</strong>, because we do not have a date_of_exit in our dataset.</p>
<p><strong>However, we do need to clean the variable “age_years”</strong>. If we look at the range of values, we get something strange:</p>
<pre class="r"><code># See the range of age_years values, removing (excluding) NA
range(linelist_cleaned$age_years, na.rm = TRUE)</code></pre>
<pre><code>## [1] &quot;0.08&quot; &quot;9&quot;</code></pre>
<p>We know there are ages older than 9 years. We check <code>class(linelist_cleaned$age_years)</code> and see that R is reading this variable as class <em>character</em>, not numeric! So we must convert it by adding the following command to the script:</p>
<pre class="r"><code># Convert variable age_years to numeric class
linelist_cleaned$age_years &lt;- as.numeric(linelist_cleaned$age_years)</code></pre>
<p><strong>Now we must further clean the age-related variables.</strong> In the chunk “Age group variables”, we do not need and can comment out the code to add under 2 years to the age_years variable. However, we do have some decimal years. To align with the data dictionary we uncomment and <strong>use the code to create a <em>new</em> variable “age_months” from the decimal years</strong>.</p>
<pre class="r"><code># For patients under 5 years, the new variable age_months is based on age_years * 12 
linelist_cleaned &lt;- mutate(linelist_cleaned,
                            age_months = case_when(
                              age_years &lt; 5 ~ age_years * 12
                              )) </code></pre>
<p>We can then use the code to create an age group variable based on age_months.</p>
<pre class="r"><code>## create age group variable for under 5 years based on months
linelist_cleaned$age_group_mon &lt;- age_categories(linelist_cleaned$age_months, 
                                                 breakers = c(0, 6, 9, 12, 24), 
                                                 ceiling = TRUE)</code></pre>
<p>…and use the similar code for groups of age_years. A note on grouping using age_categories(): for example with breakers 0, 3, 15, 30, and 45, a 30-year old patient will be included in an age_group named “30-44”.</p>
<pre class="r"><code>## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group &lt;- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 3, 15, 30, 45))</code></pre>
</div>
<div id="cleaning-categorical-variables" class="section level3">
<h3>Cleaning categorical variables</h3>
<p>While the template directs us to next create a DIED variable based on exit_status containing the characters “Dead”, we must first <strong>clean our exit_status variable, which is currrently in French</strong>.</p>
<p><strong>Use case_when() to assign new values for a new exit_status2 variable</strong>, as in the code below. The code uses the function case_when() to re-define linelist_cleaned as itself, but mutated to include the new variable exit_status2. The values in exit_status2 are based on the values in exit_status, such that when exist_status == “Décédé”, the value in exit_status2 is “Died”, and so on.</p>
<p>As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that <strong>each left-hand side (LHS) of the ~ must be a logical statement</strong>, not just a value. Best is to write case_when() lines from most specific at top to most general at bottom. You can read more about case_when() <a href="https://dplyr.tidyverse.org/reference/case_when.html">here</a>.</p>
<p><strong>Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write <code>NA</code> on the RHS. Instead you must use the special character version of <code>NA</code> : <code>NA_character_</code>.</strong></p>
<pre class="r"><code># Tabulate to see all possible values of exit_status
table(linelist_cleaned$exit_status, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##              -         Décédé Déchargé/Guéri        Echappé           &lt;NA&gt; 
##              2             14             55              2           1374</code></pre>
<pre class="r"><code># Create exit_status2 from values in exit_status
linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  mutate(exit_status2 = case_when(
    exit_status == &quot;Décédé&quot;          ~ &quot;Died&quot;,
    exit_status == &quot;-&quot;               ~ NA_character_,
    exit_status == &quot;Echappé&quot;         ~ &quot;Left&quot;,
    exit_status == &quot;Déchargé/Guéri&quot;  ~ &quot;Discharged&quot;
  ))

# Tabulate the NEW exit_status2 variable to check correct assignment
table(linelist_cleaned$exit_status2, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##       Died Discharged       Left       &lt;NA&gt; 
##         14         55          2       1376</code></pre>
<p>Now we can <strong>make the DIED variable</strong>, which is referenced in later code chunks. This command creates DIED as a logical (TRUE/FALSE) variable), depending on whether each observation meets the criteria to the right of the assignment operator <code>&lt;-</code>.</p>
<pre class="r"><code>## Note we are directing R to look within the NEW exit_status2 variable
linelist_cleaned$DIED &lt;- linelist_cleaned$exit_status2 == &quot;Died&quot;</code></pre>
</div>
<div id="re-code-values-in-patient_facility_type" class="section level3">
<h3><strong>Re-code values in patient_facility_type</strong></h3>
<p>When we assigned our variables to match the data dictionary, we used the variable “hospitalisation” as the variable “patient_facility_type”. <strong>However, the values in that variable do not match those expected by the template.</strong> In the data dictionary, patient_facility_type should have values of “Inpatient” or “Outpatient.” Currently, the values are “Oui” and “Non”. In later code chunks, analyses are restricted to observations where patient_facility_type == “Inpatient”, thus, we should align the values to match the data dictionary.</p>
<p><strong>To clean these values we uncomment and modify code from the standardise_clean_data chunk, found under the heading “recode a character variable”.</strong></p>
<pre class="r"><code># View all the values in patient_facility_type
table(linelist_cleaned$patient_facility_type, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##  Non  Oui &lt;NA&gt; 
##  699   86  662</code></pre>
<pre class="r"><code># Convert the values
linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  mutate(patient_facility_type = case_when(
    patient_facility_type == &quot;Oui&quot; ~ &quot;Inpatient&quot;,
    patient_facility_type == &quot;Non&quot; ~ &quot;Outpatient&quot;
  ))

# Re-check that the values converted sucessfully
table(linelist_cleaned$patient_facility_type, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##  Inpatient Outpatient       &lt;NA&gt; 
##         86        699        662</code></pre>
<p>We can <strong>comment/ignore the code to change the order of levels in categorical variables</strong>, as the Am Timan dataset does not include a variable time_to_death and we do not need to change the order of any categorical variables.</p>
<p><strong>However, we do need to create a case definition variable.</strong> In this use of case_when(), the last line left-hand side (LHS) is TRUE, which serves as a catch-all for any other possible values that have not yet met the criteria of the earlier case_when lines.</p>
<pre class="r"><code># You MUST modify this section to match your case definition. The below
# uses positive RDT for Confirmed and epi link only for Probable.
#
linelist_cleaned &lt;- linelist_cleaned %&gt;%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) &amp; is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == &quot;Positive&quot;                               ~ &quot;Confirmed&quot;,
    hep_e_rdt != &quot;Positive&quot; &amp; other_cases_in_hh == &quot;Yes&quot;  ~ &quot;Probable&quot;,
    TRUE                                                  ~ &quot;Suspected&quot;
  ))</code></pre>
</div>
<div id="create-lists-of-variables" class="section level3">
<h3>Create lists of variables</h3>
<p>These variables names are stored in vectors that are created using the function c(). These vectors of names will be referenced in later code chunks. This code creates two vectors - one for symptoms variables and one for laboratory testing variables.</p>
<p><strong>Some of these variables do not apply to our Am Timan data and must be removed from the list or commented out (such as convulsions and history of fever).</strong> If non-existant variables are left in the list it will cause errors in later code chunks.</p>
<pre class="r"><code># vectors of variable names ----------------------------------------------------

## You may want to group the names of several variables that have the same possible 
## values in to a named vector. 
## This way if you want to run the same function over these variables you can 
## simply use the named vector rather than typing out each variable individually

# create a grouping of all symptoms 
SYMPTOMS &lt;- c(&quot;generalized_itch&quot;, 
#             &quot;history_of_fever&quot;, 
              &quot;fever&quot;,
              &quot;joint_pains&quot;,
              &quot;epigastric_pain_heartburn&quot;,
              &quot;nausea_anorexia&quot;,
              &quot;vomiting&quot;, 
              &quot;diarrhoea&quot;,
              &quot;bleeding&quot;, 
              &quot;headache&quot;,
              &quot;mental_state&quot;,
#              &quot;convulsions&quot;,
              &quot;other_symptoms&quot;  
              )

# create a grouping of all lab tests 
LABS &lt;- c(&quot;hep_b_rdt&quot;, 
          &quot;hep_c_rdt&quot;,
          &quot;hep_e_rdt&quot;,
          &quot;test_hepatitis_a&quot;,
          &quot;test_hepatitis_b&quot;,
          &quot;test_hepatitis_c&quot;,
#          &quot;test_hepatitis_e_igg&quot;,
          &quot;test_hepatitis_e_igm&quot; ,
          &quot;test_hepatitis_e_genotype&quot;,
          &quot;test_hepatitis_e_virus&quot;,
          &quot;malaria_rdt_at_admission&quot;,
#          &quot;malaria_blood_film&quot;, 
          &quot;dengue&quot;,
#          &quot;dengue_rdt&quot;, 
          &quot;yellow_fever&quot;,
#          &quot;typhoid&quot;,
          &quot;chikungunya_onyongnyong&quot;, 
#          &quot;ebola_marburg&quot;,
#          &quot;lassa_fever&quot;,
          &quot;other_arthropod_transmitted_virus&quot; 
#          &quot;other_pathogen&quot;
          )</code></pre>
</div>
<div id="dropping-observations" class="section level3">
<h3>Dropping observations</h3>
<p>The next code assists with <strong>dropping observations and variables</strong>. We can remove any observations with date of onset after the reporting_week (reporting_week is defined at the beginning of the script).</p>
<pre class="r"><code># Drop cases after reporting week
linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  filter(date_of_onset &lt;= week2date(sprintf(&quot;%s-7&quot;, reporting_week)))</code></pre>
<p>Then, it is important to <strong>define these date-related objects</strong> that are referenced in later code chunks.</p>
<pre class="r"><code># define the first week of outbreak (date of first case)
first_week &lt;- levels(linelist_cleaned$epiweek)[1]

# outbreak start 
# return the first day in the week of first case 
obs_start &lt;- week2date(sprintf(&quot;%s-1&quot;, first_week))

# return last day of reporting week 
obs_end   &lt;- week2date(sprintf(&quot;%s-7&quot;, reporting_week))</code></pre>
</div>
<div id="export-if-desired" class="section level3">
<h3>Export if desired</h3>
<p>And finally, if desired you can <strong>export the cleaned dataset</strong> for other purposes.</p>
<pre class="r"><code>## OPTIONAL: save your cleaned dataset! 
## put the current date in the name so you know!
rio::export(linelist_cleaned, paste0(&quot;AmTiman_linelist_cleaned_&quot;, Sys.Date(), &quot;.xlsx&quot;))</code></pre>
</div>
</div>
