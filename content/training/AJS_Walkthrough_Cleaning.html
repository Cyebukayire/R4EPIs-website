---
date: "2019-08-05T14:07:44+02:00"
title: Template Walk-through - Data Import and Cleaning
weight: 8
---



<div id="overview-of-this-page" class="section level2">
<h2>Overview of this page</h2>
<p>This page will demonstrate use of the Acute Jaundice Syndrome (AJS) outbreak template using data from an outbreak in Am Timan, Chad. This first page covers the initial data importation and cleaning steps in the template.</p>
<div id="getting-started" class="section level4">
<h4>Getting started</h4>
<p><strong>Getting started with the sitrep package and opening the correct template</strong> Please review the <a href="https://r4epis.netlify.com/welcome/001-getting-started/">getting started page</a> for instructions on the following start-up steps:</p>
<ul>
<li>Downloading and configuring R and RStudio<br />
</li>
<li>Installing the sitrep package<br />
</li>
<li>Opening an outbreak or survey template</li>
</ul>
<p><strong>Access the datasets for this walk-through</strong> [instructions and link to dataset here]</p>
<p><strong>Access the final RMarkdown script used in this walk-through</strong><br />
[link to download Chad AJS RMarkdown here]</p>
<p><strong>RMarkdown resources</strong><br />
Review the page “Reading a RMarkdown Script”, or reference these resources: <a href="https://rmarkdown.rstudio.com/articles_intro.html">Rmarkdown introduction</a> and <a href="https://rmarkdown.rstudio.com/authoring_basics.html">Rmarkdown authoring basics</a>.</p>
</div>
<div id="ajshev-outbreak-in-am-timan-chad-2016-2017" class="section level4">
<h4>AJS/HEV outbreak in Am Timan, Chad (2016-2017)</h4>
<p>We will be using data and examples from a real outbreak of Hepatitis E virus (HEV) infection which occurred in the Chadian town of Am Timan between October 2016 and April 2017</p>
<p><img src="/images/AJS_Article.png" alt="AJS Article snip", width = "40%"></p>
<p><a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0188240">Link to publication</a></p>
<p><em>DISCLAIMER: The real data from the outbreak has been used for the training materials linked to the outbreak templates of the R4epis project. The Chadian Ministry of Health (MoH) has approved the use of this data for training purposes. Please note, that some data has been adapted in order to best achieve training objectives. Also, the GPS coordinates included in the dataset do not correspond to real cases identified during this outbreak. They have been generated exclusively for training purposes.</em></p>
<p>In early September 2016, a cluster of severely ill pregnant women with jaundice was detected at the Am Timan Hospital in the maternity ward. Following rapid tests conducted in Am Timan and confirmatory testing in the Netherlands, this was confirmed as due to HEV infection. Thus the MoH and MSF outbreak response was activated. The response consisted of four components: 1) active community based surveillance (CBS), 2) clinical assessment and management of ill cases at the hospital, 3) water chlorination activities at most water points in the town, 4) hygiene promotion.</p>
<p>The outbreak linelist data was combined data from the active CBS data and the clinical data from the hospital. The CBS functioned with community health workers visiting all households in the town every two weeks and actively searching for people with Acute Jaundice Syndrome (AJS). For this group of persons (suspected cases), only those that were visibly ill or that were pregnant were referred to the hospital for clinical assessment and admission if required. Persons that self-reported to the hospital or that arrived after referral would undergo a clinical assessment and a rapid test for HEV for diagnosis. Thus only for people assessed at the hospital were we able to capture a confirmed case status.</p>
<p>For the duration of the outbreak we detected 1193 suspected cases, 100 confirmed cases and discarded 150 cases with AJS who were not positive for HEV infection.</p>
</div>
</div>
<div id="overview-of-template" class="section level2">
<h2>Overview of template</h2>
<p>Graphic showing big-picture overview of template parts</p>
</div>
<div id="template-header-and-introduction" class="section level2">
<h2>Template header and introduction</h2>
<p>The very top of the template consists of a header surrounded by <code>---</code> lines. Here you may want to edit the title of your document. The other settings in the header define the default document type produced (Microsoft Word) when the RMarkdown is “knit”.</p>
<p>The “Introduction to this template” section is for your information only and this text can be deleted before knitting the document.</p>
<p><img src="/images/AJS_Intro.png" alt="AJS Header and Introduction snip", width = "75%"></p>
</div>
<div id="installation-and-loading-required-packages" class="section level2">
<h2>Installation and loading required packages</h2>
<p><strong>The text which explains the purpose of this code chunk may be deleted, but you must keep the code chunk!</strong> The code will run without producing any output in your final report, but it is required to install (or load using library(), if already installed) the packages necessary to produce the report. You can read more about the packages used by the template on this <a href="https://r4epis.netlify.com/outbreaks/">page</a></p>
<p>This “setup” code chunk does the following:</p>
<ul>
<li><p>Set default settings for tables such as size, error handling, and display of missing values</p></li>
<li><p>Create a vector of names of packages required for the template to run, each of which is installed if it is not already installed, and then is loaded using library() for use in the current R session.</p></li>
<li><p>Set default text size in graphic plots</p></li>
<li><p>Set epidemiological weeks to begin on Mondays</p></li>
</ul>
<p><img src="/images/Package_Installation.png" alt="Package installation chunk snip", width = "75%"></p>
</div>
<div id="set-current-epi-week" class="section level2">
<h2>Set current epi week</h2>
<p>Set the epidemiological week for the report. <strong>This value is used in later code chunks, for example when producing epidemic curves.</strong> Note that you may want to specify the most recent <strong>complete</strong> epi week.</p>
<p>Follow the format demonstrated below:</p>
<blockquote>
<p>Within quotes (&quot; “) give the 4-digit year, a hyphen (-), capital W, then the 2-digit epi week number</p>
</blockquote>
<p>By default in the templates epi weeks begin on Mondays (this can be changed at the bottom of the “setup” code chunk). See the documentation of the <a href="https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html">package “aweek”</a> for more information.</p>
<pre class="r"><code>reporting_week &lt;- &quot;2017-W52&quot;  # Set the reporting week</code></pre>
<p>To determine which epi week it is currently (based on the template epi week settings), use the code below:</p>
<pre class="r"><code>date2week(Sys.Date())      #Sys.Date() uses the current date from your computer</code></pre>
<pre><code>## &lt;aweek start: Monday&gt;
## [1] &quot;2019-W33-5&quot;</code></pre>
</div>
<div id="import-the-dataset" class="section level2">
<h2>Import the dataset</h2>
<p><strong>In this template section you choose the appropriate code chunk to importing your dataset.</strong></p>
<p><img src="/images/AJS_Data_Import.png" alt="Data import options snip", width = "75%"></p>
<p>For this exercise our dataset is a <strong>non-standardized Excel file</strong> from MSF’s response an outbreak of AJS in Am Timan, Chad, so we use the <code>read_nonDHIS_data</code> code chunk, specifically the line that uses the import() function of the rio package to import an Excel file that is not password protected.</p>
<p>Note that errors can occur if you provide an incorrect file name or path.</p>
<pre class="r"><code>## Read data ------------------------------------
# Excel file
# to read in a specific sheet use &quot;which&quot;
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;)</code></pre>
<p>There should now be a dataframe object named “linelist_raw” in your environment pane, consisting of 1447 observations and 122 variables.</p>
<p><img src="/images/linelist_raw_imported.png" alt="Environment snip with linelist_raw", width = "50%"></p>
</div>
<div id="aligning-the-dataset-with-the-data-dictionary" class="section level2">
<h2>Aligning the dataset with the data dictionary</h2>
<p>When using a non-standardized dataset, the variable names and values must be aligned with the data dictionary. <strong>This process can take some time</strong> and requires looking back-and-forth between your dataset, RStudio, and the MSF data dictionary. In this example, here are the steps taken:</p>
<div id="review-the-msf-data-dictionary" class="section level3">
<h3>Review the MSF data dictionary</h3>
<p>Use this command found in the template to view the MSF data dictionary for the disease (“AJS” in this example).</p>
<pre class="r"><code># creates object linelist_dict using the msf_dict function from the sitrep package
linelist_dict &lt;- msf_dict(&quot;AJS&quot;, compact = FALSE) %&gt;%
  select(option_code, option_name, everything())</code></pre>
<p>The dataframe linelist_dict should appear in your Environment pane. You can view the data dictionary by running the command <code>View(linelist_dict)</code> (note capital V), or by clicking linelist_dict in the Environment pane.</p>
<div class="figure">
<img src="/images/AJS_Data_Dictionary.png" />

</div>
</div>
<div id="clean-the-variable-names" class="section level3">
<h3>Clean the variable names</h3>
<p>This step standardizes how your variable names are written, such as changing spaces and dots to underscores (“_“). <strong>Uncomment the appropriate lines of template code</strong>.</p>
<p><strong>First, make a copy of the dataframe linelist_raw but with a new name: linelist_cleaned.</strong> Throughout the template you will modify and improve this linelist_cleaned dataframe. However, you can always return to the linelist_raw version for reference.</p>
<pre class="r"><code>## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned &lt;- linelist_raw</code></pre>
<p><strong>Second, use the clean_labels() function</strong> from the epitrix package to fix any variable names with non-standard syntax. These code lines take the column names, clean them, and then store the cleaned names in the vector cleaned_colnames. The second code line over-writes the old column names of linelist_cleaned with the improved ones.</p>
<pre class="r"><code># Store cleaned column names
cleaned_colnames &lt;- epitrix::clean_labels(colnames(linelist_raw))

# Overwrite variable column names with clean ones
colnames(linelist_cleaned) &lt;- cleaned_colnames</code></pre>
</div>
<div id="re-name-variables-to-align-with-data-dictionary" class="section level3">
<h3>Re-name variables to align with data dictionary</h3>
<p>Standardized variable names are required for this template to work smoothly, and the variable names in our Am Timan dataset do not align with the names this template expects. The template offers code that you can uncomment if you only have to change a few variable names (see below). <strong>However, in this example we need to change many variable names. For this scenario, MSF developed a special function to help map our variables to the expected variable names.</strong></p>
<ul>
<li><strong>Paste the disease-specific rename helper into the script.</strong> This command is found in the template near the end of the “read_nonDHIS_data”&quot; chunk. For our example we run the command <code>msf_dict_rename_helper(&quot;AJS&quot;)</code> and a block of code text is copied to our clipboard. Return to the template script and <em>paste</em> from the clipboard into the template. For the AJS template, the code that is pasted will look like the code below. This code uses the function rename() to change variable names.</li>
</ul>
<p>*Note: Be sure to paste the code into an existing R code chunk, not into the white space of the RMarkdown script.</p>
<p><img src="/images/Variable_Helper_Paste.gif" alt="rename variables empty snip", width = "100%"></p>
<ul>
<li><strong>Complete the mapping of variable names.</strong> To the right of the equals sign, and before the comma, type the <em>exact</em> names of the variables from your dataset that correspond to the expected MSF data dictionary variables on the left. <em>If there is a data dictionary variable that is not present in your dataset, be sure to comment (#) out that line, as shown in the GIF below.</em></li>
</ul>
<div class="figure">
<img src="/images/AJS_Variable_Names.gif" />

</div>
<p><strong>Tip: </strong>If you see this error:<br />
<code>Error in is_symbol(expr) : argument &quot;expr&quot; is missing, with no default</code><br />
then you likely forgot to comment (#) the line for a variable you did not use.</p>
<p>And now you can see the result:</p>
<p><img src="/images/AJS_Rename_Variables_Proof.png" alt="rename variables proof", width = "100%"></p>
</div>
</div>
<div id="provide-population-counts" class="section level2">
<h2>Provide population counts</h2>
<p>The population estimates for regions and age groups are collected in order to calculate attack and mortality rates. <strong>The template allows several ways to provide population estimates, but importantly, the data must be stored under specific variable names.</strong> The specific age groupings and region names in your data frames may differ from the examples, but the variable names but follow the expected standard.</p>
<p>You can do one of the following:<br />
1) Enter the estimates directly <strong>[need clarification here as this is not yet built]</strong><br />
2) Use the function gen_population() to derive the estimates from proportions<br />
3) Import a spreadsheet file with the estimates in the correct format</p>
<div class="figure">
<img src="/images/AJS_Population_Counts.png" />

</div>
<p>For the AJS example, we can use the population Excel spreadsheet, importing it with the template code as below. Note that the variables names have been edited to match the expected names (“patient_origin” and “population”).</p>
<blockquote>
<p>The file path you provide to the function may differ. A few notes about file paths:<br />
* If copying a file path from Microsoft computer, you will need to reverse any slashes from  to /.<br />
* [NOTES ON USING HERE and RIO::IMPORT]</p>
</blockquote>
<pre class="r"><code>population_data_region &lt;- rio::import(&quot;AJS_AmTiman_population_revised_for_template.xlsx&quot;, which=&quot;quartier&quot;)</code></pre>
<p><strong>If you choose not to complete the population estimates section, delete the default gen_population() code, and expect that later sections on attack and mortality rates will not produce output.</strong></p>
</div>
<div id="lab-data" class="section level2">
<h2>Lab data</h2>
<p>[Paragraph about lab data here - how it is used]</p>
</div>
<div id="creating-and-cleaning-variables" class="section level2">
<h2>Creating and cleaning variables</h2>
<p>The variables and values in our example AJS dataset are still very different from the standard AJS MSF data dictionary. In the data cleaning steps we will need to do the following:</p>
<div id="re-code-missing-values-from-periods-.-to-na-at-import" class="section level3">
<h3><strong>Re-code missing values from periods (.) to <code>NA</code> at import</strong></h3>
<p>Currently, missing values in the dataset are represented by a period (.). This causes problems because R expects missing values to be coded as <code>NA</code>. For example, if we attempt to set the variable date_of_onset to class Date, R gives an error because the periods are considered character values that do not fit the expected YYYY-MM-DD date format.</p>
<p>To fix this problem we <strong>scroll up to the data import section of the template and insert an additional argument in the import command</strong>. The argument <code>na = &quot;.&quot;</code> specifies a period as the value in the Excel sheet that R will consider to be “missing”. As the data are imported, all cells with that value are changed to <code>NA</code>.</p>
<p><strong>Remember that after making this change to the import command you must re-run the entire script. This way, the dataset is imported correctly AND the changes to variable names, etc. are also performed on this newly imported dataset</strong></p>
<pre class="r"><code># The old import command
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;)

# The revised import command (don&#39;t forget the comma between arguments!)
linelist_raw &lt;- rio::import(&quot;AJS_AmTiman.xlsx&quot;, which = &quot;linelist&quot;, na = &quot;.&quot;)</code></pre>
</div>
<div id="set-date-variables-to-class-date" class="section level3">
<h3><strong>Set date variables to class Date</strong></h3>
<p>In linelist_cleaned there are seven variables containing dates (dateentry, epiquestdate, date_of_admission, date_of_onset, date_lab_sample_taken, dthospitalisation, dtdeath).</p>
<p><strong>IF</strong> your dataset <em>completely</em> aligns with the MSF data dictionary then use the code in the template that converts all the date variables to class Date at once.</p>
<pre class="r"><code># Use this is your dataset aligns with the data dictionary
# Creates list of date variables from the data dictionary
DATEVARS &lt;- filter(linelist_dict, data_element_valuetype == &quot;DATE&quot;) %&gt;% 
  select(data_element_shortname) # select date vars
# change to the date variables found in your dataset to class date 
linelist_cleaned &lt;- linelist_cleaned %&gt;%
  mutate_at(DATEVARS$data_element_shortname, as.Date)</code></pre>
<p>However, if your dataset is at all unstandard you will need to use this code instead.</p>
<pre class="r"><code># Use this if your dataset does not align with the data dictionary
  linelist_cleaned &lt;- linelist_cleaned %&gt;%
    mutate_at(vars(matches(&quot;date|Date&quot;)), linelist::guess_dates,
            error_tolerance = 0.5)</code></pre>
<pre><code>## Warning in (function (x, error_tolerance = 0.1, first_date = NULL, last_date = Sys.Date(), : 
## The following 1 dates were not in the correct timeframe (1969-08-16 -- 2019-08-16):
## 
##   original  |  parsed    
##   --------  |  ------    
##   8736      |  1923-12-01</code></pre>
<pre><code>## Warning in (function (x, error_tolerance = 0.1, first_date = NULL, last_date = Sys.Date(), : 
## The following 3 dates were not in the correct timeframe (1969-08-16 -- 2019-08-16):
## 
##   original    |  parsed    
##   --------    |  ------    
##   1900-07-24  |  1900-07-24
##   1930-02-01  |  1930-02-01
##   1931-02-01  |  1931-02-01</code></pre>
<p>In our Am Timan dataset, this code converted many of our date variables, but did not detect the variables named with “dt”, such as “dtdeath” and “dthospitalization”. We must convert those manually:</p>
<pre class="r"><code># Individually convert other date columns
class(linelist_cleaned$dthospitalisation)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>linelist_cleaned$dthospitalisation &lt;- linelist::guess_dates(linelist_cleaned$dthospitalisation)

class(linelist_cleaned$dthospitalisation)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<pre class="r"><code># Repeat for variable &quot;dtdeath&quot;
linelist_cleaned$dtdeath &lt;- linelist::guess_dates(linelist_cleaned$dtdeath)</code></pre>
</div>
<div id="re-code-values-in-patient_facility_type" class="section level3">
<h3><strong>Re-code values in patient_facility_type</strong></h3>
<p>When we assigned our variables to match the data dictionary, we used the variable “hospitalisation” as the variable “patient_facility_type”. <strong>However, the values in that variable do not match those expected by the template.</strong> In the data dictionary, patient_facility_type should have values of “Inpatient” or “Outpatient.” Currently, the values are “Oui” and “Non”. In later code chunks, analyses are restricted to observations where patient_facility_type == “Inpatient”, thus, we should align the values to match the data dictionary.</p>
<p><strong>To clean these values we modify code from the standardise_clean_data template chunk.</strong> The code below uses the function case_when() to re-define linelist_cleaned as itself, but mutated such that when its value equals “Oui”, that value is changed (~) to “Inpatient”, and so on. If applicable, write these case_when() lines from most specific at top to most general at bottom (see section on creating a case definition variable).</p>
<p>As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that <strong>each left-hand side (LHS) of the ~ must be a logical statement</strong>, not just a value. You can read more about case_when() <a href="https://dplyr.tidyverse.org/reference/case_when.html">here</a>.</p>
<p><strong>Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write <code>NA</code> on the RHS. Instead you must use the special character version of <code>NA</code> : <code>NA_character_</code>.</strong></p>
<pre class="r"><code># View all the values in patient_facility_type
table(linelist_cleaned$patient_facility_type, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##  Non  Oui &lt;NA&gt; 
##  699   86  662</code></pre>
<pre class="r"><code># Convert the values
linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  mutate(patient_facility_type = case_when(
    patient_facility_type == &quot;Oui&quot; ~ &quot;Inpatient&quot;,
    patient_facility_type == &quot;Non&quot; ~ &quot;Outpatient&quot;
  ))

# Re-check that the values converted sucessfully
table(linelist_cleaned$patient_facility_type, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##  Inpatient Outpatient       &lt;NA&gt; 
##         86        699        662</code></pre>
</div>
<div id="other-data-cleaning-steps" class="section level3">
<h3>Other data cleaning steps</h3>
<p>There are many sections of code in the data cleaning chunk that you can use as necessary. These are the steps taken for the Am Timan example:</p>
<ul>
<li><strong>Create a new epi week variable</strong><br />
The template provides code to create a new epi week variable based on date_of_onset.</li>
</ul>
<pre class="r"><code># create an epiweek variable
# floor_day shortens to only give you the week number (rather than including day as well) 
# factor includes all weeks between the min and max as levels (useful for zero count weeks)
linelist_cleaned$epiweek &lt;- aweek::date2week(linelist_cleaned$date_of_onset, 
                                             floor_day = TRUE, 
                                             factor = TRUE)</code></pre>
<ul>
<li><p><strong>Comment out code for “create number of days under observation”</strong>, because our dataset does not have a date of exit variable.</p></li>
<li><p><strong>Comment out code that creates the age_group_mon variable</strong>, because our dataset only has age_years</p></li>
<li><p><strong>Create the age_group variable</strong> as below (based on age_years):</p></li>
</ul>
<pre class="r"><code>## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group &lt;- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 3, 15, 30, 45))</code></pre>
<ul>
<li><strong>Use case_when() to assign new values for a new exit_status2 variable</strong>, as in the code below:</li>
</ul>
<pre class="r"><code># Tabulate to see all possible values of exit_status
table(linelist_cleaned$exit_status, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##              -         Décédé Déchargé/Guéri        Echappé           &lt;NA&gt; 
##              2             14             55              2           1374</code></pre>
<pre class="r"><code>linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  mutate(exit_status2 = case_when(
    exit_status == &quot;Décédé&quot;          ~ &quot;Died&quot;,
    exit_status == &quot;-&quot;               ~ NA_character_,
    exit_status == &quot;Echappé&quot;         ~ &quot;Left&quot;,
    exit_status == &quot;Déchargé/Guéri&quot;  ~ &quot;Discharged&quot;
  ))

# Table the NEW variable to check transformation
table(linelist_cleaned$exit_status2, useNA = &quot;always&quot;)</code></pre>
<pre><code>## 
##       Died Discharged       Left       &lt;NA&gt; 
##         14         55          2       1376</code></pre>
<ul>
<li><strong>Create DIED variable</strong><br />
Now that we have translated the exit status values, we can make the DIED variable (which is referenced in later code).</li>
</ul>
<pre class="r"><code>## Note we are looking within the NEW exit_status2 variable that is in English
linelist_cleaned$DIED &lt;- linelist_cleaned$exit_status2 == &quot;Died&quot;</code></pre>
<ul>
<li><strong>Create case definition variable</strong></li>
</ul>
<pre class="r"><code># Create a factor variable based on rules from other simple character variables
# If you have access to lab results, you can create a case definition variable 
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
# starting from the specific to the general
# TRUE assigns all remaining rows 
# You MUST modify this section to match your case definition. The below
# uses positive RDT for Confirmed and epi link only for Probable.
#
linelist_cleaned &lt;- linelist_cleaned %&gt;%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) &amp; is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == &quot;Positive&quot;                               ~ &quot;Confirmed&quot;,
    hep_e_rdt != &quot;Positive&quot; &amp; other_cases_in_hh == &quot;Yes&quot;  ~ &quot;Probable&quot;,
    TRUE                                                  ~ &quot;Suspected&quot;
  ))</code></pre>
<ul>
<li><strong>Create lists of symptom variables</strong> <strong>already switched “med” variables to these ones, but some do not apply and must be removed from the list, such as convulsions and history of fever?</strong></li>
</ul>
<pre class="r"><code># vectors of variable names ----------------------------------------------------

## You may want to group the names of several variables that have the same possible 
## values in to a named vector. 
## This way if you want to run the same function over these variables you can 
## simply use the named vector rather than typing out each variable individually

# create a grouping of all symptoms 
SYMPTOMS &lt;- c(&quot;generalized_itch&quot;, 
              #&quot;history_of_fever&quot;, 
              &quot;fever&quot;,
              &quot;joint_pains&quot;,
              &quot;epigastric_pain_heartburn&quot;,
              &quot;nausea_anorexia&quot;,
              &quot;vomiting&quot;, 
              &quot;diarrhoea&quot;,
              &quot;bleeding&quot;, 
              &quot;headache&quot;,
              &quot;mental_state&quot;,
              #&quot;convulsions&quot;,
              &quot;other_symptoms&quot;  
              )

# create a grouping of all lab tests 
LABS &lt;- c(&quot;hep_b_rdt&quot;, 
          &quot;hep_c_rdt&quot;,
          &quot;hep_e_rdt&quot;,
          &quot;test_hepatitis_a&quot;,
          &quot;test_hepatitis_b&quot;,
          &quot;test_hepatitis_c&quot;,
#          &quot;test_hepatitis_e_igg&quot;,
          &quot;test_hepatitis_e_igm&quot; ,
          &quot;test_hepatitis_e_genotype&quot;,
          &quot;test_hepatitis_e_virus&quot;,
          &quot;malaria_rdt_at_admission&quot;,
#          &quot;malaria_blood_film&quot;, 
          &quot;dengue&quot;,
#          &quot;dengue_rdt&quot;, 
          &quot;yellow_fever&quot;,
#          &quot;typhoid&quot;,
          &quot;chikungunya_onyongnyong&quot;, 
#          &quot;ebola_marburg&quot;,
#          &quot;lassa_fever&quot;,
          &quot;other_arthropod_transmitted_virus&quot; 
#          &quot;other_pathogen&quot;
          )</code></pre>
<ul>
<li><strong>Drop observations</strong> Remove observations with date of onset outside outbreak dates. This should reduce the number of observations in linelist_cleaned from 1447 to 1434.</li>
</ul>
<pre class="r"><code># Check date range of date_of_onset
range(linelist_cleaned$date_of_onset, na.rm = T)</code></pre>
<pre><code>## [1] &quot;2014-11-01&quot; &quot;2017-12-27&quot;</code></pre>
<pre class="r"><code># Filter to keep observations where date_of_onset after April 2016 AND before October 2017 (OR missing)
linelist_cleaned &lt;- linelist_cleaned %&gt;%
  filter((date_of_onset &gt;= as.Date(&quot;2016-04-01&quot;) &amp; date_of_onset &lt;= as.Date(&quot;2017-10-01&quot;)) | is.na(date_of_onset))

# Re-check the date range
range(linelist_cleaned$date_of_onset, na.rm = T)</code></pre>
<pre><code>## [1] &quot;2016-06-09&quot; &quot;2017-04-22&quot;</code></pre>
<ul>
<li><strong>Optionally, you can export the cleaned dataset</strong> for other purposes</li>
</ul>
<pre class="r"><code>## OPTIONAL: save your cleaned dataset as an excel file! 
## put the current date in the name so you know!
writexl::write_xlsx(linelist_cleaned, paste0(&quot;linelist_cleaned_&quot;, Sys.Date(), &quot;.xlsx&quot;))</code></pre>
<ul>
<li><strong>Drop cases after reporting week.</strong> Remember, you defined the reporting_week at beginning of the script.</li>
</ul>
<pre class="r"><code># drop cases after current week
# you will probably have cases in your dataset if case finding continues
# as these are after the week of reporting, drop them
linelist_cleaned &lt;- linelist_cleaned %&gt;% 
  filter(date_of_onset &lt;= week2date(sprintf(&quot;%s-7&quot;, reporting_week)))</code></pre>
<ul>
<li><strong>Define these date-related objects</strong> that are referenced later in the template script.</li>
</ul>
<pre class="r"><code># define the first week of outbreak (date of first case)
first_week &lt;- levels(linelist_cleaned$epiweek)[1]

# outbreak start 
# return the first day in the week of first case 
obs_start &lt;- week2date(sprintf(&quot;%s-1&quot;, first_week))

# return last day of reporting week 
obs_end   &lt;- week2date(sprintf(&quot;%s-7&quot;, reporting_week))</code></pre>
</div>
</div>
