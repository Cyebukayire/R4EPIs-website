---
date: "2019-08-05T14:07:44+02:00"
title: Template Walk-through - Data Import and Cleaning
weight: 8
---


```{r setup, include=FALSE, results='hide', message=FALSE, warning=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = TRUE,       # hide all code chunks in output
                      error = TRUE,       # show errors if they appear, but don't stop
                      fig.width = 6*1.25, # Figure width
                      fig.height = 6      # Figure height
                     )
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")

# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "dplyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "ggplot2",     # create plots and charts
                       "sitrep",      # MSF field epi functions
                       "linelist",    # Functions for cleaning/standardising data
                       "incidence",   # create epicurves
                       "aweek",       # define epi weeks
                       "epitools",    # 2x2 tables and other epi goodness
                       "sf",          # encode spatial vector data
                       "ggspatial")   # plot maps

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}


# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))

# Set the day that defines the beginning of your epiweek.
# you can start the week on any day of the week
# (the ISO standard is to start on Monday) 
aweek::set_week_start("Monday")
```

## Overview of this page
This page will demonstrate use of the Acute Jaundice Syndrome (AJS) outbreak template using data from an outbreak in Am Timan, Chad. This first page covers the initial data importation and cleaning steps in the template.  

#### Getting started  

**Getting started with the sitrep package and opening the correct template**
Please review the [getting started page](https://r4epis.netlify.com/welcome/001-getting-started/) for instructions on the following start-up steps:  

* Downloading and configuring R and RStudio  
* Installing the sitrep package  
* Opening an outbreak or survey template  

**Access the datasets for this walk-through**
[instructions and link to dataset here]

**Access the final RMarkdown script used in this walk-through**  
[link to download Chad AJS RMarkdown here]

**RMarkdown resources**  
Review the page "Reading a RMarkdown Script", or reference these resources: [Rmarkdown introduction](https://rmarkdown.rstudio.com/articles_intro.html) and [Rmarkdown authoring basics](https://rmarkdown.rstudio.com/authoring_basics.html).  

  


#### AJS/HEV outbreak in Am Timan, Chad (2016-2017)

We will be using data and examples from a real outbreak of Hepatitis E virus (HEV) infection which occurred in the Chadian town of Am Timan between October 2016 and April 2017  

<img src="/images/AJS_Article.png" alt="AJS Article snip", width = "40%">

[Link to publication](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0188240)  

*DISCLAIMER: The real data from the outbreak has been used for the training materials linked to the outbreak templates of the R4epis project. The Chadian Ministry of Health (MoH) has approved the use of this data for training purposes. Please note, that some data has been adapted in order to best achieve training objectives. Also, the GPS coordinates included in the dataset do not correspond to real cases identified during this outbreak. They have been generated exclusively for training purposes.*  

In early September 2016, a cluster of severely ill pregnant women with jaundice was detected at the Am Timan Hospital in the maternity ward. Following rapid tests conducted in Am Timan and confirmatory testing in the Netherlands, this was confirmed as due to HEV infection. Thus the MoH and MSF outbreak response was activated. The response consisted of four components: 1) active community based surveillance (CBS), 2) clinical assessment and management of ill cases at the hospital, 3) water chlorination activities at most water points in the town, 4) hygiene promotion.  

The outbreak linelist data was combined data from the active CBS data and the clinical data from the hospital. The CBS functioned with community health workers visiting all households in the town every two weeks and actively searching for people with Acute Jaundice Syndrome (AJS). For this group of persons (suspected cases), only those that were visibly ill or that were pregnant were referred to the hospital for clinical assessment and admission if required. Persons that self-reported to the hospital or that arrived after referral would undergo a clinical assessment and a rapid test for HEV for diagnosis. Thus only for people assessed at the hospital were we able to capture a confirmed case status.  

For the duration of the outbreak we detected 1193 suspected cases, 100 confirmed cases and discarded 150 cases with AJS who were not positive for HEV infection.  

## Overview of template 

Graphic showing big-picture overview of template parts  

## Template header and introduction

The very top of the template consists of a header surrounded by `---` lines. Here you may want to edit the title of your document. The other settings in the header define the default document type produced (Microsoft Word) when the RMarkdown is "knit".

The "Introduction to this template" section is for your information only and this text can be deleted before knitting the document.  

<img src="/images/AJS_Intro.png" alt="AJS Header and Introduction snip", width = "75%">


## Installation and loading required packages
**The text which explains the purpose of this code chunk may be deleted, but you must keep the code chunk!** The code will run without producing any output in your final report, but it is required to install (or load using library(), if already installed) the packages necessary to produce the report. You can read more about the packages used by the template on this [page](https://r4epis.netlify.com/outbreaks/)

This "setup" code chunk does the following:  

* Set default settings for tables such as size, error handling, and display of missing values  

* Create a vector of names of packages required for the template to run, each of which is installed if it is not already installed, and then is loaded using library() for use in the current R session.

* Set default text size in graphic plots  

* Set epidemiological weeks to begin on Mondays  

<img src="/images/Package_Installation.png" alt="Package installation chunk snip", width = "75%">


## Set current epi week  
Set the epidemiological week for the report. **This value is used in later code chunks, for example when producing epidemic curves.** Note that you may want to specify the most recent **complete** epi week.  

Follow the format demonstrated below:  

> Within quotes (" ") give the 4-digit year, a hyphen (-), capital W, then the 2-digit epi week number  

By default in the templates epi weeks begin on Mondays (this can be changed at the bottom of the "setup" code chunk). See the documentation of the [package "aweek"](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html) for more information. 

```{r}
reporting_week <- "2017-W52"  # Set the reporting week
```

To determine which epi week it is currently (based on the template epi week settings), use the code below:

```{r}
date2week(Sys.Date())      #Sys.Date() uses the current date from your computer
```

## Import the dataset

**In this template section you choose the appropriate code chunk to importing your dataset.** 

<img src="/images/AJS_Data_Import.png" alt="Data import options snip", width = "75%">

For this exercise our dataset is a **non-standardized Excel file** from MSF's response an outbreak of AJS in Am Timan, Chad, so we use the `read_nonDHIS_data` code chunk, specifically the line that uses the import() function of the rio package to import an Excel file that is not password protected.  

Note that errors can occur if you provide an incorrect file name or path. 


```{r eval=FALSE}
## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist")
```

There should now be a dataframe object named "linelist_raw" in your environment pane, consisting of 1447 observations and 122 variables.  

<img src="/images/linelist_raw_imported.png" alt="Environment snip with linelist_raw", width = "50%">



```{r include=FALSE, results='hide', message=FALSE, warning=FALSE}
# This code chunk runs in the background and actually imports the dataset while transforming "." to NA.
# The import code chunk above (with eval=FALSE) does not run, but shows the viewer the default import code.
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist", na=".")
```


## Aligning the dataset with the data dictionary  
When using a non-standardized dataset, the variable names and values must be aligned with the data dictionary. **This process can take some time** and requires looking back-and-forth between your dataset, RStudio, and the MSF data dictionary. In this example, here are the steps taken:  

### Review the MSF data dictionary
Use this command found in the template to view the MSF data dictionary for the disease ("AJS" in this example).

```{r eval = FALSE}
# creates object linelist_dict using the msf_dict function from the sitrep package
linelist_dict <- msf_dict("AJS", compact = FALSE) %>%
  select(option_code, option_name, everything())
```

The dataframe linelist_dict should appear in your Environment pane. You can view the data dictionary by running the command `View(linelist_dict)` (note capital V), or by clicking linelist_dict in the Environment pane.  

![](/images/AJS_Data_Dictionary.png)

### Clean the variable names  
This step standardizes how your variable names are written, such as changing spaces and dots to underscores ("_"). **Uncomment the appropriate lines of template code**.  

**First, make a copy of the dataframe linelist_raw but with a new name: linelist_cleaned.** Throughout the template you will modify and improve this linelist_cleaned dataframe. However, you can always return to the linelist_raw version for reference.  

```{r}
## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw
```

**Second, use the clean_labels() function** from the epitrix package to fix any variable names with non-standard syntax. These code lines take the column names, clean them, and then store the cleaned names in the vector cleaned_colnames. The second code line over-writes the old column names of linelist_cleaned with the improved ones.

```{r}
# Store cleaned column names
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

# Overwrite variable column names with clean ones
colnames(linelist_cleaned) <- cleaned_colnames
```

### Re-name variables to align with data dictionary  

Standardized variable names are required for this template to work smoothly, and the variable names in our Am Timan dataset do not align with the names this template expects. The template offers code that you can uncomment if you only have to change a few variable names (see below). **However, in this example we need to change many variable names. For this scenario, MSF developed a special function to help map our variables to the expected variable names.**  

* **Paste the disease-specific rename helper into the script.** This command is found in the template near the end of the "read_nonDHIS_data"" chunk. For our example we run the command `msf_dict_rename_helper("AJS")` and a block of code text is copied to our clipboard. Return to the template script and *paste* from the clipboard into the template. For the AJS template, the code that is pasted will look like the code below. This code uses the function rename() to change variable names.  

*Note: Be sure to paste the code into an existing R code chunk, not into the white space of the RMarkdown script. 

<img src="/images/Variable_Helper_Paste.gif" alt="rename variables empty snip", width = "100%">

* **Complete the mapping of variable names.** To the right of the equals sign, and before the comma, type the *exact* names of the variables from your dataset that correspond to the expected MSF data dictionary variables on the left. *If there is a data dictionary variable that is not present in your dataset, be sure to comment (#) out that line, as shown in the GIF below.*

![](/images/AJS_Variable_Names.gif)  

**Tip: **If you see this error:  
`Error in is_symbol(expr) : argument "expr" is missing, with no default`  
then you likely forgot to comment (#) the line for a variable you did not use.  

And now you can see the result:  

<img src="/images/AJS_Rename_Variables_Proof.png" alt="rename variables proof", width = "100%">


```{r include=FALSE, results='hide', message=FALSE, warning=FALSE}
## Add the appropriate column names after the equals signs

linelist_cleaned <- rename(linelist_cleaned,
#  event_file_type                   =   , # TEXT                # (Not in dataset)
  case_number                       =   hevid, # TEXT
  date_of_admission                 =   dtmedical, # DATE
  detected_by                       =   referredby, # TEXT
  patient_facility_type             =   hospitalised, # TEXT
#  msf_involvement                   =   , # TEXT                # (Not in dataset)
  age_years                         =   age, # INTEGER_POSITIVE
#  age_months                        =   , # INTEGER_POSITIVE   # (Dataset only has years)
#  age_days                          =   , # INTEGER_POSITIVE   # (Dataset only has years)
  sex                               =   sex, # TEXT
  patient_origin                    =   quartier, # ORG UNIT
#  residential_status_brief          =   , # TEXT               # (Not in dataset)
#  arrival_date_in_area_if_3m        =   , # DATE               # (Not in dataset)
#  ever_received_hepatitis_e_vaccine =   , # TEXT               # (Not in dataset)
#  date_of_last_vaccination          =   , # DATE               # (Not in dataset)
  date_of_onset                     =   dtjaundice, # DATE
#  history_of_fever                  =   , # BOOLEAN            # (Not in dataset)
  fever                             =   medfever, # BOOLEAN
  nausea_anorexia                   =   mednausea, # BOOLEAN
  vomiting                          =   medvomit, # BOOLEAN
  epigastric_pain_heartburn         =   medepigastric, # BOOLEAN
  generalized_itch                  =   meditching, # BOOLEAN
  headache                          =   medheadache, # BOOLEAN
  joint_pains                       =   medarthralgia, # BOOLEAN
  diarrhoea                         =   meddiar, # BOOLEAN
  bleeding                          =   medbleeding, # BOOLEAN
#  convulsions                       =   , # BOOLEAN            # (Not in dataset)
  mental_state                      =   medmental, # BOOLEAN    # !(Needs value cleaning)
  other_symptoms                    =   medother, # BOOLEAN
  other_cases_in_hh                 =   medothhhajs, # BOOLEAN
#  traditional_medicines             =   , # BOOLEAN            # (Not in dataset)
#  traditional_medicine_details      =   , # TEXT               # (Not in dataset)
#  recent_travel                     =   , # BOOLEAN            # (Not in dataset)
#  water_source                      =   , # TEXT               # !(Split across many variables)
  malaria_rdt_at_admission          =   medmalrdt, # TEXT
  hep_b_rdt                         =   medhepb, # TEXT
  hep_c_rdt                         =   medhepc, # TEXT
  hep_e_rdt                         =   medhevrdt, # TEXT
#  dengue_rdt                        =   , # TEXT               # (Not in dataset)
  date_lab_sample_taken             =   medblooddt, # DATE
  test_hepatitis_a                  =   medhavelisa, # TEXT
  test_hepatitis_b                  =   medhbvelisa, # TEXT
  test_hepatitis_c                  =   medhcvelisa, # TEXT
  test_hepatitis_e_virus            =   medhevelisa, # TEXT
  test_hepatitis_e_igm              =   hevrecent, # TEXT
#  test_hepatitis_e_igg              =   , # TEXT               # (In same variable as elisa result)
  test_hepatitis_e_genotype         =   hevgenotype, # TEXT
#  malaria_blood_film                =   , # TEXT               # (Not in dataset)
  dengue                            =   dengue, # TEXT
  yellow_fever                      =   yf, # TEXT
#  lassa_fever                       =   , # TEXT               # (Not in dataset)
#  typhoid                           =   , # TEXT               # (Not in dataset)
  chikungunya_onyongnyong           =   chik, # TEXT
#  ebola_marburg                     =   , # TEXT               # (Not in dataset)
  other_arthropod_transmitted_virus =   arbovpcr, # TEXT
#  other_pathogen                    =   , # TEXT               # (Not in dataset)
#  lab_comments                      =   , # TEXT               # (Not in dataset)
  pregnant                          =   medpreg, # TEXT
  trimester                         =   medpregtri, # TEXT
#  foetus_alive_at_admission         =   , # TEXT               # (Not in dataset)
#  delivery_event                    =   , # TRUE_ONLY          # (Not in dataset)
  pregnancy_outcome_at_exit         =   medppoutcome, # TEXT
  exit_status                       =   outcomehp, # TEXT
#  date_of_exit                      =   , # DATE               # (Not in dataset)
#  time_to_death                     =   , # TEXT               # (Not in dataset)
  treatment_facility_site           =   hpid, # TEXT
#  treatment_location                =   , # ORGANISATION_UNIT  # (Not in dataset)
  patient_origin_free_text          =   block # TEXT
)
```


## Provide population counts  
The population estimates for regions and age groups are collected in order to calculate attack and mortality rates. **The template allows several ways to provide population estimates, but importantly, the data must be stored under specific variable names.** The specific age groupings and region names in your data frames may differ from the examples, but the variable names but follow the expected standard.  

You can do one of the following:  
1) Enter the estimates directly **[need clarification here as this is not yet built]**  
2) Use the function gen_population() to derive the estimates from proportions  
3) Import a spreadsheet file with the estimates in the correct format  

![](/images/AJS_Population_Counts.png)  

For the AJS example, we can use the population Excel spreadsheet, importing it with the template code as below. Note that the variables names have been edited to match the expected names ("patient_origin" and "population").  

>The file path you provide to the function may differ. A few notes about file paths:  
* If copying a file path from Microsoft computer, you will need to reverse any slashes from \ to /.  
* [NOTES ON USING HERE and RIO::IMPORT]  

```{r}
population_data_region <- rio::import("AJS_AmTiman_population_revised_for_template.xlsx", which="quartier")
```


**If you choose not to complete the population estimates section, delete the default gen_population() code, and expect that later sections on attack and mortality rates will not produce output.**


## Lab data
[Paragraph about lab data here - how it is used]  



## Creating and cleaning variables  
The variables and values in our example AJS dataset are still very different from the standard AJS MSF data dictionary. In the data cleaning steps we will need to do the following:  

### **Re-code missing values from periods (.) to `NA` at import**  

Currently, missing values in the dataset are represented by a period (.). This causes problems because R expects missing values to be coded as `NA`. For example, if we attempt to set the variable date_of_onset to class Date, R gives an error because the periods are considered character values that do not fit the expected YYYY-MM-DD date format.  

To fix this problem we **scroll up to the data import section of the template and insert an additional argument in the import command**. The argument `na = "."` specifies a period as the value in the Excel sheet that R will consider to be "missing". As the data are imported, all cells with that value are changed to `NA`.  

**Remember that after making this change to the import command you must re-run the entire script. This way, the dataset is imported correctly AND the changes to variable names, etc. are also performed on this newly imported dataset** 

```{r eval=FALSE}
# The old import command
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist")

# The revised import command (don't forget the comma between arguments!)
linelist_raw <- rio::import("AJS_AmTiman.xlsx", which = "linelist", na = ".")
```



### **Set date variables to class Date**
In linelist_cleaned there are seven variables containing dates (dateentry, epiquestdate, date_of_admission, date_of_onset, date_lab_sample_taken, dthospitalisation, dtdeath).  

**IF** your dataset *completely* aligns with the MSF data dictionary then use the code in the template that converts all the date variables to class Date at once.

```{r eval=FALSE}
# Use this is your dataset aligns with the data dictionary
# Creates list of date variables from the data dictionary
DATEVARS <- filter(linelist_dict, data_element_valuetype == "DATE") %>% 
  select(data_element_shortname) # select date vars
# change to the date variables found in your dataset to class date 
linelist_cleaned <- linelist_cleaned %>%
  mutate_at(DATEVARS$data_element_shortname, as.Date)
```


However, if your dataset is at all unstandard you will need to use this code instead.  
```{r}
# Use this if your dataset does not align with the data dictionary
  linelist_cleaned <- linelist_cleaned %>%
    mutate_at(vars(matches("date|Date")), linelist::guess_dates,
            error_tolerance = 0.5)
```

In our Am Timan dataset, this code converted many of our date variables, but did not detect the variables named with "dt", such as "dtdeath" and "dthospitalization". We must convert those manually:
```{r}
# Individually convert other date columns
class(linelist_cleaned$dthospitalisation)

linelist_cleaned$dthospitalisation <- linelist::guess_dates(linelist_cleaned$dthospitalisation)

class(linelist_cleaned$dthospitalisation)

# Repeat for variable "dtdeath"
linelist_cleaned$dtdeath <- linelist::guess_dates(linelist_cleaned$dtdeath)
```

### **Re-code values in patient_facility_type**  

When we assigned our variables to match the data dictionary, we used the variable "hospitalisation" as the variable "patient_facility_type". **However, the values in that variable do not match those expected by the template.** In the data dictionary, patient_facility_type should have values of "Inpatient" or "Outpatient." Currently, the values are "Oui" and "Non". In later code chunks, analyses are restricted to observations where patient_facility_type == "Inpatient", thus, we should align the values to match the data dictionary.  

**To clean these values we modify code from the standardise_clean_data template chunk.** The code below uses the function case_when() to re-define linelist_cleaned as itself, but mutated such that when its value equals "Oui", that value is changed (~) to "Inpatient", and so on. If applicable, write these case_when() lines from most specific at top to most general at bottom (see section on creating a case definition variable).

As you modify this chunk for your own situation, remember to include commas at the end of each case_when() line (except the last one), and that **each left-hand side (LHS) of the ~ must be a logical statement**, not just a value. You can read more about case_when() [here](https://dplyr.tidyverse.org/reference/case_when.html).  

**Tip: All the right-hand side (RHS) values must be the same class (either character, numeric, etc.). So, if your other RHS values are character and you want one RHS value to be missing, you cannot just write `NA` on the RHS. Instead you must use the special character version of `NA` : `NA_character_`.** 

```{r}
# View all the values in patient_facility_type
table(linelist_cleaned$patient_facility_type, useNA = "always")

# Convert the values
linelist_cleaned <- linelist_cleaned %>% 
  mutate(patient_facility_type = case_when(
    patient_facility_type == "Oui" ~ "Inpatient",
    patient_facility_type == "Non" ~ "Outpatient"
  ))

# Re-check that the values converted sucessfully
table(linelist_cleaned$patient_facility_type, useNA = "always")

```


### Other data cleaning steps
There are many sections of code in the data cleaning chunk that you can use as necessary. These are the steps taken for the Am Timan example:  

* **Create a new epi week variable**  
The template provides code to create a new epi week variable based on date_of_onset.
```{r}
# create an epiweek variable
# floor_day shortens to only give you the week number (rather than including day as well) 
# factor includes all weeks between the min and max as levels (useful for zero count weeks)
linelist_cleaned$epiweek <- aweek::date2week(linelist_cleaned$date_of_onset, 
                                             floor_day = TRUE, 
                                             factor = TRUE)
```

* **Comment out code for "create number of days under observation"**, because our dataset does not have a date of exit variable.  

* **Comment out code that creates the age_group_mon variable**, because our dataset only has age_years  

* **Create the age_group variable** as below (based on age_years):

```{r}
## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 3, 15, 30, 45))
```

* **Use case_when() to assign new values for a new exit_status2 variable**, as in the code below:  

```{r}
# Tabulate to see all possible values of exit_status
table(linelist_cleaned$exit_status, useNA = "always")

linelist_cleaned <- linelist_cleaned %>% 
  mutate(exit_status2 = case_when(
    exit_status == "Décédé"          ~ "Died",
    exit_status == "-"               ~ NA_character_,
    exit_status == "Echappé"         ~ "Left",
    exit_status == "Déchargé/Guéri"  ~ "Discharged"
  ))

# Table the NEW variable to check transformation
table(linelist_cleaned$exit_status2, useNA = "always")
```


* **Create DIED variable**  
Now that we have translated the exit status values, we can make the DIED variable (which is referenced in later code).

```{r}
## Note we are looking within the NEW exit_status2 variable that is in English
linelist_cleaned$DIED <- linelist_cleaned$exit_status2 == "Died"
```


* **Create case definition variable**

```{r}
# Create a factor variable based on rules from other simple character variables
# If you have access to lab results, you can create a case definition variable 
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
# starting from the specific to the general
# TRUE assigns all remaining rows 
# You MUST modify this section to match your case definition. The below
# uses positive RDT for Confirmed and epi link only for Probable.
#
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == "Positive"                               ~ "Confirmed",
    hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
    TRUE                                                  ~ "Suspected"
  ))
```

* **Create lists of symptom variables**
**already switched "med" variables to these ones, but some do not apply and must be removed from the list, such as convulsions and history of fever?**

```{r}
# vectors of variable names ----------------------------------------------------

## You may want to group the names of several variables that have the same possible 
## values in to a named vector. 
## This way if you want to run the same function over these variables you can 
## simply use the named vector rather than typing out each variable individually

# create a grouping of all symptoms 
SYMPTOMS <- c("generalized_itch", 
              #"history_of_fever", 
              "fever",
              "joint_pains",
              "epigastric_pain_heartburn",
              "nausea_anorexia",
              "vomiting", 
              "diarrhoea",
              "bleeding", 
              "headache",
              "mental_state",
              #"convulsions",
              "other_symptoms"  
              )

# create a grouping of all lab tests 
LABS <- c("hep_b_rdt", 
          "hep_c_rdt",
          "hep_e_rdt",
          "test_hepatitis_a",
          "test_hepatitis_b",
          "test_hepatitis_c",
#          "test_hepatitis_e_igg",
          "test_hepatitis_e_igm" ,
          "test_hepatitis_e_genotype",
          "test_hepatitis_e_virus",
          "malaria_rdt_at_admission",
#          "malaria_blood_film", 
          "dengue",
#          "dengue_rdt", 
          "yellow_fever",
#          "typhoid",
          "chikungunya_onyongnyong", 
#          "ebola_marburg",
#          "lassa_fever",
          "other_arthropod_transmitted_virus" 
#          "other_pathogen"
          )

```

* **Drop observations** Remove observations with date of onset outside outbreak dates. This should reduce the number of observations in linelist_cleaned from 1447 to 1434.

```{r}
# Check date range of date_of_onset
range(linelist_cleaned$date_of_onset, na.rm = T)

# Filter to keep observations where date_of_onset after April 2016 AND before October 2017 (OR missing)
linelist_cleaned <- linelist_cleaned %>%
  filter((date_of_onset >= as.Date("2016-04-01") & date_of_onset <= as.Date("2017-10-01")) | is.na(date_of_onset))

# Re-check the date range
range(linelist_cleaned$date_of_onset, na.rm = T)
```



* **Optionally, you can export the cleaned dataset** for other purposes

```{r save_cleaned_data, eval = FALSE}
## OPTIONAL: save your cleaned dataset as an excel file! 
## put the current date in the name so you know!
writexl::write_xlsx(linelist_cleaned, paste0("linelist_cleaned_", Sys.Date(), ".xlsx"))
```



* **Drop cases after reporting week.** Remember, you defined the reporting_week at beginning of the script.  

```{r}

# drop cases after current week
# you will probably have cases in your dataset if case finding continues
# as these are after the week of reporting, drop them
linelist_cleaned <- linelist_cleaned %>% 
  filter(date_of_onset <= week2date(sprintf("%s-7", reporting_week)))
```

* **Define these date-related objects** that are referenced later in the template script.  

```{r}
# define the first week of outbreak (date of first case)
first_week <- levels(linelist_cleaned$epiweek)[1]

# outbreak start 
# return the first day in the week of first case 
obs_start <- week2date(sprintf("%s-1", first_week))

# return last day of reporting week 
obs_end   <- week2date(sprintf("%s-7", reporting_week))

```



